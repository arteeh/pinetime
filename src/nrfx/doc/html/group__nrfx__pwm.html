<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nrfx 2.0: PWM driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nrfx
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__nrfx__pwm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PWM driver<div class="ingroups"><a class="el" href="group__nrf__pwm.html">PWM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Pulse Width Modulation (PWM) peripheral driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__nrfx__pwm__config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm__config.html">PWM peripheral driver configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver instance data structure.  <a href="structnrfx__pwm__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver configuration structure.  <a href="structnrfx__pwm__config__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga248fea7bfb810bed3145b9927b7ab679"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga248fea7bfb810bed3145b9927b7ab679">NRFX_PWM_INSTANCE</a>(id)</td></tr>
<tr class="memdesc:ga248fea7bfb810bed3145b9927b7ab679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for creating a PWM driver instance.  <a href="#ga248fea7bfb810bed3145b9927b7ab679">More...</a><br/></td></tr>
<tr class="separator:ga248fea7bfb810bed3145b9927b7ab679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d0f4652322f07b3225d8be97984bfdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8d0f4652322f07b3225d8be97984bfdc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga8d0f4652322f07b3225d8be97984bfdc">NRFX_PWM_PIN_NOT_USED</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga8d0f4652322f07b3225d8be97984bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value can be provided instead of a pin number for any channel to specify that its output is not used and therefore does not need to be connected to a pin. <br/></td></tr>
<tr class="separator:ga8d0f4652322f07b3225d8be97984bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga730fb957fc2eec7d963a44f6631bbb63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga730fb957fc2eec7d963a44f6631bbb63"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga730fb957fc2eec7d963a44f6631bbb63">NRFX_PWM_PIN_INVERTED</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:ga730fb957fc2eec7d963a44f6631bbb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value can be added to a pin number to invert its polarity (set idle state = 1). <br/></td></tr>
<tr class="separator:ga730fb957fc2eec7d963a44f6631bbb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc78a6d1474cbf684932a84e06567321"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gabc78a6d1474cbf684932a84e06567321">NRFX_PWM_DEFAULT_CONFIG</a>(_out_0, _out_1, _out_2, _out_3)</td></tr>
<tr class="memdesc:gabc78a6d1474cbf684932a84e06567321"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver default configuration.  <a href="#gabc78a6d1474cbf684932a84e06567321">More...</a><br/></td></tr>
<tr class="separator:gabc78a6d1474cbf684932a84e06567321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaadd1b66955999cfca2f9197b1077c5ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaadd1b66955999cfca2f9197b1077c5ba"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gaadd1b66955999cfca2f9197b1077c5ba">nrfx_pwm_handler_t</a> )(<a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a> event_type, void *p_context)</td></tr>
<tr class="memdesc:gaadd1b66955999cfca2f9197b1077c5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver event handler type. <br/></td></tr>
<tr class="separator:gaadd1b66955999cfca2f9197b1077c5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">nrfx_pwm_flag_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18">NRFX_PWM_FLAG_STOP</a> = 0x01, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4ce524255d29bb74352584be77ac3bad">NRFX_PWM_FLAG_LOOP</a> = 0x02, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213">NRFX_PWM_FLAG_SIGNAL_END_SEQ0</a> = 0x04, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa">NRFX_PWM_FLAG_SIGNAL_END_SEQ1</a> = 0x08, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4971c619bfc960e43ae4ac4a790a8465">NRFX_PWM_FLAG_NO_EVT_FINISHED</a> = 0x10, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> = 0x80
<br/>
 }</td></tr>
<tr class="memdesc:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM flags providing additional playback options.  <a href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">More...</a><br/></td></tr>
<tr class="separator:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd252a13f482085e89e23516b8a422a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa087e425c2519f35f5db0b0a85222406f">NRFX_PWM_EVT_FINISHED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30">NRFX_PWM_EVT_END_SEQ0</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957">NRFX_PWM_EVT_END_SEQ1</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a">NRFX_PWM_EVT_STOPPED</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga3bd252a13f482085e89e23516b8a422a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver event type.  <a href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">More...</a><br/></td></tr>
<tr class="separator:ga3bd252a13f482085e89e23516b8a422a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga433c4fe4493b296fe7ac1d63f9af0cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga433c4fe4493b296fe7ac1d63f9af0cd0">nrfx_pwm_init</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *p_config, <a class="el" href="group__nrfx__pwm.html#gaadd1b66955999cfca2f9197b1077c5ba">nrfx_pwm_handler_t</a> handler, void *p_context)</td></tr>
<tr class="memdesc:ga433c4fe4493b296fe7ac1d63f9af0cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing the PWM driver.  <a href="#ga433c4fe4493b296fe7ac1d63f9af0cd0">More...</a><br/></td></tr>
<tr class="separator:ga433c4fe4493b296fe7ac1d63f9af0cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ba03e5984116112721858d2cd6bec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gac6ba03e5984116112721858d2cd6bec6">nrfx_pwm_uninit</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gac6ba03e5984116112721858d2cd6bec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for uninitializing the PWM driver.  <a href="#gac6ba03e5984116112721858d2cd6bec6">More...</a><br/></td></tr>
<tr class="separator:gac6ba03e5984116112721858d2cd6bec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15874083a69d6c88e827b3ccb51dec25"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga15874083a69d6c88e827b3ccb51dec25">nrfx_pwm_simple_playback</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence, uint16_t playback_count, uint32_t flags)</td></tr>
<tr class="memdesc:ga15874083a69d6c88e827b3ccb51dec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for starting a single sequence playback.  <a href="#ga15874083a69d6c88e827b3ccb51dec25">More...</a><br/></td></tr>
<tr class="separator:ga15874083a69d6c88e827b3ccb51dec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15573667e4fd472d77398ede40bb473"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gad15573667e4fd472d77398ede40bb473">nrfx_pwm_complex_playback</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence_0, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence_1, uint16_t playback_count, uint32_t flags)</td></tr>
<tr class="memdesc:gad15573667e4fd472d77398ede40bb473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for starting a two-sequence playback.  <a href="#gad15573667e4fd472d77398ede40bb473">More...</a><br/></td></tr>
<tr class="separator:gad15573667e4fd472d77398ede40bb473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb5b014424ec8f6fda40f55da6ff1f6"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gacfb5b014424ec8f6fda40f55da6ff1f6">nrfx_pwm_step</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gacfb5b014424ec8f6fda40f55da6ff1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for advancing the active sequence.  <a href="#gacfb5b014424ec8f6fda40f55da6ff1f6">More...</a><br/></td></tr>
<tr class="separator:gacfb5b014424ec8f6fda40f55da6ff1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f47b9142d4ae40284cd8044be9ea35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gae7f47b9142d4ae40284cd8044be9ea35">nrfx_pwm_stop</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, bool wait_until_stopped)</td></tr>
<tr class="memdesc:gae7f47b9142d4ae40284cd8044be9ea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for stopping the sequence playback.  <a href="#gae7f47b9142d4ae40284cd8044be9ea35">More...</a><br/></td></tr>
<tr class="separator:gae7f47b9142d4ae40284cd8044be9ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f48343db6466475711036fe99dde59a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga3f48343db6466475711036fe99dde59a">nrfx_pwm_is_stopped</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance)</td></tr>
<tr class="memdesc:ga3f48343db6466475711036fe99dde59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking the status of the PWM peripheral.  <a href="#ga3f48343db6466475711036fe99dde59a">More...</a><br/></td></tr>
<tr class="separator:ga3f48343db6466475711036fe99dde59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749917a72aaee584a76427021980098d"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga749917a72aaee584a76427021980098d">nrfx_pwm_sequence_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, uint8_t seq_id, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence)</td></tr>
<tr class="memdesc:ga749917a72aaee584a76427021980098d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the sequence data during playback.  <a href="#ga749917a72aaee584a76427021980098d">More...</a><br/></td></tr>
<tr class="separator:ga749917a72aaee584a76427021980098d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b249a31a4b6996e0cb1e47f7300281e"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga4b249a31a4b6996e0cb1e47f7300281e">nrfx_pwm_sequence_values_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, uint8_t seq_id, <a class="el" href="unionnrf__pwm__values__t.html">nrf_pwm_values_t</a> values)</td></tr>
<tr class="memdesc:ga4b249a31a4b6996e0cb1e47f7300281e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the pointer to the duty cycle values in the specified sequence during playback.  <a href="#ga4b249a31a4b6996e0cb1e47f7300281e">More...</a><br/></td></tr>
<tr class="separator:ga4b249a31a4b6996e0cb1e47f7300281e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df655251f648e52848bb9c6cfee419f"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga6df655251f648e52848bb9c6cfee419f">nrfx_pwm_sequence_length_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, uint8_t seq_id, uint16_t length)</td></tr>
<tr class="memdesc:ga6df655251f648e52848bb9c6cfee419f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the number of duty cycle values in the specified sequence during playback.  <a href="#ga6df655251f648e52848bb9c6cfee419f">More...</a><br/></td></tr>
<tr class="separator:ga6df655251f648e52848bb9c6cfee419f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2b905f990faa23be0fb826e32d649c0"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gaf2b905f990faa23be0fb826e32d649c0">nrfx_pwm_sequence_repeats_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, uint8_t seq_id, uint32_t repeats)</td></tr>
<tr class="memdesc:gaf2b905f990faa23be0fb826e32d649c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the number of repeats for duty cycle values in the specified sequence during playback.  <a href="#gaf2b905f990faa23be0fb826e32d649c0">More...</a><br/></td></tr>
<tr class="separator:gaf2b905f990faa23be0fb826e32d649c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97522ecb3eb88bf0bc2608274adabf4"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gab97522ecb3eb88bf0bc2608274adabf4">nrfx_pwm_sequence_end_delay_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, uint8_t seq_id, uint32_t end_delay)</td></tr>
<tr class="memdesc:gab97522ecb3eb88bf0bc2608274adabf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the additional delay after the specified sequence during playback.  <a href="#gab97522ecb3eb88bf0bc2608274adabf4">More...</a><br/></td></tr>
<tr class="separator:gab97522ecb3eb88bf0bc2608274adabf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6355991cc62d20dff3e6d8c97af43b0"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gab6355991cc62d20dff3e6d8c97af43b0">nrfx_pwm_task_address_get</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="group__nrf__pwm__hal.html#ga11cb9ca8fbb773011a3ad6658914418e">nrf_pwm_task_t</a> task)</td></tr>
<tr class="memdesc:gab6355991cc62d20dff3e6d8c97af43b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of a specified PWM task that can be used in PPI module.  <a href="#gab6355991cc62d20dff3e6d8c97af43b0">More...</a><br/></td></tr>
<tr class="separator:gab6355991cc62d20dff3e6d8c97af43b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga092229079f29535058054026a97501e9"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga092229079f29535058054026a97501e9">nrfx_pwm_event_address_get</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="group__nrf__pwm__hal.html#ga4a8ceac653433e4ac8ee8682bdef45bf">nrf_pwm_event_t</a> event)</td></tr>
<tr class="memdesc:ga092229079f29535058054026a97501e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of a specified PWM event that can be used in PPI module.  <a href="#ga092229079f29535058054026a97501e9">More...</a><br/></td></tr>
<tr class="separator:ga092229079f29535058054026a97501e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Pulse Width Modulation (PWM) peripheral driver. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gabc78a6d1474cbf684932a84e06567321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_DEFAULT_CONFIG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                \</div>
<div class="line">    .output_pins  = { _out_0,                                    \</div>
<div class="line">                      _out_1,                                    \</div>
<div class="line">                      _out_2,                                    \</div>
<div class="line">                      _out_3                                     \</div>
<div class="line">                    },                                           \</div>
<div class="line">    .irq_priority = <a class="code" href="group__nrfx__pwm__config.html#ga097ff5d073d1266dde45fbe2b0dbddc9" title="Interrupt priority.">NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY</a>,        \</div>
<div class="line">    .base_clock   = <a class="code" href="group__nrf__pwm__hal.html#gga8479da20e14394fb2388b1be3b879670a30e595429e6787e18df7ca04b897bb11" title="16 MHz / 16 = 1 MHz.">NRF_PWM_CLK_1MHz</a>,                            \</div>
<div class="line">    .count_mode   = <a class="code" href="group__nrf__pwm__hal.html#gga1f29b190ff13c52895d249e07ebe92cba0b9d394af2cbadb2fd430f73e6b2a28c" title="Up counter (edge-aligned PWM duty cycle).">NRF_PWM_MODE_UP</a>,                             \</div>
<div class="line">    .top_value    = 1000,                                        \</div>
<div class="line">    .load_mode    = <a class="code" href="group__nrf__pwm__hal.html#gga453888e5feb46774da27499ca1eeafd2a23a17dad88a8dff161e09c5057e70362" title="1st half word (16-bit) used in all PWM channels (0-3).">NRF_PWM_LOAD_COMMON</a>,                         \</div>
<div class="line">    .step_mode    = <a class="code" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aec7f52e96da457170f1a516ea78357a1" title="Automatically after the current value is played and repeated the requested number of times...">NRF_PWM_STEP_AUTO</a>,                           \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>PWM driver default configuration. </p>
<p>This configuration sets up PWM with the following options:</p>
<ul>
<li>clock frequency: 1 MHz</li>
<li>count up</li>
<li>top value: 1000 clock ticks</li>
<li>load mode: common</li>
<li>step mode: auto</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_out_0</td><td>PWM output 0 pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_out_1</td><td>PWM output 1 pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_out_2</td><td>PWM output 2 pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_out_3</td><td>PWM output 3 pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga248fea7bfb810bed3145b9927b7ab679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_INSTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                           \</div>
<div class="line">    .p_registers  = <a class="code" href="group__nrfx__common.html#ga9fced903f4d0fc450e63d40426050236" title="Macro for concatenating two tokens in macro expansion.">NRFX_CONCAT_2</a>(NRF_PWM, <span class="keywordtype">id</span>),             \</div>
<div class="line">    .drv_inst_idx = <a class="code" href="group__nrfx__common.html#gaa78d21b07d22f7a4bfbd1feda51ef1f4" title="Macro for concatenating three tokens in macro expansion.">NRFX_CONCAT_3</a>(NRFX_PWM, <span class="keywordtype">id</span>, _INST_IDX), \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Macro for creating a PWM driver instance. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga3bd252a13f482085e89e23516b8a422a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM driver event type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga3bd252a13f482085e89e23516b8a422aa087e425c2519f35f5db0b0a85222406f"></a>NRFX_PWM_EVT_FINISHED</em>&nbsp;</td><td class="fielddoc">
<p>Sequence playback finished. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30"></a>NRFX_PWM_EVT_END_SEQ0</em>&nbsp;</td><td class="fielddoc">
<p>End of sequence 0 reached. Its data can be safely modified now. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957"></a>NRFX_PWM_EVT_END_SEQ1</em>&nbsp;</td><td class="fielddoc">
<p>End of sequence 1 reached. Its data can be safely modified now. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a"></a>NRFX_PWM_EVT_STOPPED</em>&nbsp;</td><td class="fielddoc">
<p>The PWM peripheral has been stopped. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga68ffb6414b8b5e07ddb4e14431b2bd1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">nrfx_pwm_flag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM flags providing additional playback options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18"></a>NRFX_PWM_FLAG_STOP</em>&nbsp;</td><td class="fielddoc">
<p>When the requested playback is finished, the peripheral will be stopped. </p>
<dl class="section note"><dt>Note</dt><dd>The STOP task is triggered when the last value of the final sequence is loaded from RAM, and the peripheral stops at the end of the current PWM period. For sequences with configured repeating of duty cycle values, this might result in less than the requested number of repeats of the last value. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4ce524255d29bb74352584be77ac3bad"></a>NRFX_PWM_FLAG_LOOP</em>&nbsp;</td><td class="fielddoc">
<p>When the requested playback is finished, it will be started from the beginning. This flag is ignored if used together with <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18">NRFX_PWM_FLAG_STOP</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The playback restart is done via a shortcut configured in the PWM peripheral. This shortcut triggers the proper starting task when the final value of previous playback is read from RAM and applied to the pulse generator counter. When this mechanism is used together with the <a class="el" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aa64f9312c7d5928aadcaf7596e61357b">NRF_PWM_STEP_TRIGGERED</a> mode, the playback restart will occur right after switching to the final value (this final value will be played only once). </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213"></a>NRFX_PWM_FLAG_SIGNAL_END_SEQ0</em>&nbsp;</td><td class="fielddoc">
<p>The event handler is to be called when the last value from sequence 0 is loaded. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa"></a>NRFX_PWM_FLAG_SIGNAL_END_SEQ1</em>&nbsp;</td><td class="fielddoc">
<p>The event handler is to be called when the last value from sequence 1 is loaded. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4971c619bfc960e43ae4ac4a790a8465"></a>NRFX_PWM_FLAG_NO_EVT_FINISHED</em>&nbsp;</td><td class="fielddoc">
<p>The playback finished event (enabled by default) is to be suppressed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec"></a>NRFX_PWM_FLAG_START_VIA_TASK</em>&nbsp;</td><td class="fielddoc">
<p>The playback must not be started directly by the called function. Instead, the function must only prepare it and return the address of the task to be triggered to start the playback. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad15573667e4fd472d77398ede40bb473"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_pwm_complex_playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>playback_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for starting a two-sequence playback. </p>
<p>Use the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag if you want the playback to be only prepared by this function, and you want to start it later by triggering a task (using PPI for instance). The function will then return the address of the task to be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The array containing the duty cycle values for the specified sequence must be in RAM and cannot be allocated on the stack. For detailed information, see <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence_0</td><td>First sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence_1</td><td>Second sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playback_count</td><td>Number of playbacks to be performed (must not be 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Additional options. Pass any combination of <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">playback flags</a>, or 0 for default settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the task to be triggered to start the playback if the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag was used, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga092229079f29535058054026a97501e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE uint32_t nrfx_pwm_event_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__pwm__hal.html#ga4a8ceac653433e4ac8ee8682bdef45bf">nrf_pwm_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of a specified PWM event that can be used in PPI module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Requested event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event address. </dd></dl>

</div>
</div>
<a class="anchor" id="ga433c4fe4493b296fe7ac1d63f9af0cd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_pwm_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrfx__pwm.html#gaadd1b66955999cfca2f9197b1077c5ba">nrfx_pwm_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing the PWM driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Pointer to the structure with the initial configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Event handler provided by the user. If NULL is passed instead, event notifications are not done and PWM interrupts are disabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_context</td><td>Context passed to the event handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Initialization was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>The driver was already initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3f48343db6466475711036fe99dde59a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_pwm_is_stopped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking the status of the PWM peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The PWM peripheral is stopped. </td></tr>
    <tr><td class="paramname">false</td><td>The PWM peripheral is not stopped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab97522ecb3eb88bf0bc2608274adabf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_pwm_sequence_end_delay_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the additional delay after the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_delay</td><td>New end delay value (in PWM periods). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6df655251f648e52848bb9c6cfee419f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_pwm_sequence_length_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the number of duty cycle values in the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>New number of the duty cycle values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf2b905f990faa23be0fb826e32d649c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_pwm_sequence_repeats_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>repeats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the number of repeats for duty cycle values in the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repeats</td><td>New number of repeats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga749917a72aaee584a76427021980098d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_pwm_sequence_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the sequence data during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence</td><td>Pointer to the new sequence definition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b249a31a4b6996e0cb1e47f7300281e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_pwm_sequence_values_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionnrf__pwm__values__t.html">nrf_pwm_values_t</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the pointer to the duty cycle values in the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>New pointer to the duty cycle values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15874083a69d6c88e827b3ccb51dec25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_pwm_simple_playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>playback_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for starting a single sequence playback. </p>
<p>To take advantage of the looping mechanism in the PWM peripheral, both sequences must be used (single sequence can be played back only once by the peripheral). Therefore, the provided sequence is internally set and played back as both sequence 0 and sequence 1. Consequently, if the end of sequence notifications are required, events for both sequences must be used (that is, both the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213">NRFX_PWM_FLAG_SIGNAL_END_SEQ0</a> flag and the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa">NRFX_PWM_FLAG_SIGNAL_END_SEQ1</a> flag must be specified, and the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30">NRFX_PWM_EVT_END_SEQ0</a> event and the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957">NRFX_PWM_EVT_END_SEQ1</a> event must be handled in the same way).</p>
<p>Use the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag if you want the playback to be only prepared by this function, and you want to start it later by triggering a task (for example, by using PPI). The function will then return the address of the task to be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The array containing the duty cycle values for the specified sequence must be in RAM and cannot be allocated on the stack. For detailed information, see <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence</td><td>Sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playback_count</td><td>Number of playbacks to be performed (must not be 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Additional options. Pass any combination of <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">playback flags</a>, or 0 for default settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the task to be triggered to start the playback if the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag was used, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gacfb5b014424ec8f6fda40f55da6ff1f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_pwm_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for advancing the active sequence. </p>
<p>This function only applies to <a class="el" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aa64f9312c7d5928aadcaf7596e61357b">NRF_PWM_STEP_TRIGGERED</a> mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae7f47b9142d4ae40284cd8044be9ea35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_pwm_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_stopped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for stopping the sequence playback. </p>
<p>The playback is stopped at the end of the current PWM period. This means that if the active sequence is configured to repeat each duty cycle value for a certain number of PWM periods, the last played value might appear on the output less times than requested.</p>
<dl class="section note"><dt>Note</dt><dd>This function can be instructed to wait until the playback is stopped (by setting <code>wait_until_stopped</code> to true). Depending on the length of the PMW period, this might take a significant amount of time. Alternatively, the <a class="el" href="group__nrfx__pwm.html#ga3f48343db6466475711036fe99dde59a">nrfx_pwm_is_stopped</a> function can be used to poll the status, or the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a">NRFX_PWM_EVT_STOPPED</a> event can be used to get the notification when the playback is stopped, provided the event handler is defined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_until_stopped</td><td>If true, the function will not return until the playback is stopped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The PWM peripheral is stopped. </td></tr>
    <tr><td class="paramname">false</td><td>The PWM peripheral is not stopped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab6355991cc62d20dff3e6d8c97af43b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE uint32_t nrfx_pwm_task_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__pwm__hal.html#ga11cb9ca8fbb773011a3ad6658914418e">nrf_pwm_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of a specified PWM task that can be used in PPI module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>Requested task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task address. </dd></dl>

</div>
</div>
<a class="anchor" id="gac6ba03e5984116112721858d2cd6bec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_pwm_uninit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for uninitializing the PWM driver. </p>
<p>If any sequence playback is in progress, it is stopped immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="https://github.com/NordicSemiconductor/nrfx/issues" target="_blank">nrfx feedback</a> | <a href="https://devzone.nordicsemi.com/" target="_blank">Nordic DevZone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Wed Nov 6 2019" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
</script>
</div>
</body>
</html>
