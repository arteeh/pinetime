<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nrfx 2.0: USBD HAL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nrfx
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__nrf__usbd__hal.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USBD HAL<div class="ingroups"><a class="el" href="group__nrf__usbd.html">USBD</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Hardware access layer for managing the Universal Serial Bus Device (USBD) peripheral.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6bf887bf2b95efe9128ba52eccfae9a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga6bf887bf2b95efe9128ba52eccfae9a9">NRF_USBD_FRAMECNTR_SIZE</a>&#160;&#160;&#160;( (USBD_FRAMECNTR_FRAMECNTR_Msk &gt;&gt; USBD_FRAMECNTR_FRAMECNTR_Pos) + 1UL )</td></tr>
<tr class="memdesc:ga6bf887bf2b95efe9128ba52eccfae9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frame counter size.  <a href="#ga6bf887bf2b95efe9128ba52eccfae9a9">More...</a><br/></td></tr>
<tr class="separator:ga6bf887bf2b95efe9128ba52eccfae9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2885b53c22521a2a3e2dbcda0dd0f044"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga2885b53c22521a2a3e2dbcda0dd0f044">NRF_USBD_EPISO_FIRST</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga2885b53c22521a2a3e2dbcda0dd0f044"><td class="mdescLeft">&#160;</td><td class="mdescRight">First isochronous endpoint number.  <a href="#ga2885b53c22521a2a3e2dbcda0dd0f044">More...</a><br/></td></tr>
<tr class="separator:ga2885b53c22521a2a3e2dbcda0dd0f044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b9553409d9c4785eebaaadd4586f0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga44b9553409d9c4785eebaaadd4586f0f">NRF_USBD_EPIN_CNT</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:ga44b9553409d9c4785eebaaadd4586f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of IN endpoints.  <a href="#ga44b9553409d9c4785eebaaadd4586f0f">More...</a><br/></td></tr>
<tr class="separator:ga44b9553409d9c4785eebaaadd4586f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437407a2f8d28b360a4ec9eb816e729d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga437407a2f8d28b360a4ec9eb816e729d">NRF_USBD_EPOUT_CNT</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:ga437407a2f8d28b360a4ec9eb816e729d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of OUT endpoints.  <a href="#ga437407a2f8d28b360a4ec9eb816e729d">More...</a><br/></td></tr>
<tr class="separator:ga437407a2f8d28b360a4ec9eb816e729d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab440dd7f6a642c240348da60092eb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafab440dd7f6a642c240348da60092eb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gafab440dd7f6a642c240348da60092eb3">NRF_USBD_EP_DIR_Msk</a>&#160;&#160;&#160;(1U &lt;&lt; 7)</td></tr>
<tr class="memdesc:gafab440dd7f6a642c240348da60092eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of the direction bit in an endpoint number. <br/></td></tr>
<tr class="separator:gafab440dd7f6a642c240348da60092eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6357a6cf3e265f3f1c40077582cdc814"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6357a6cf3e265f3f1c40077582cdc814"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga6357a6cf3e265f3f1c40077582cdc814">NRF_USBD_EP_DIR_IN</a>&#160;&#160;&#160;(1U &lt;&lt; 7)</td></tr>
<tr class="memdesc:ga6357a6cf3e265f3f1c40077582cdc814"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of direction bit for the IN endpoint direction. <br/></td></tr>
<tr class="separator:ga6357a6cf3e265f3f1c40077582cdc814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e374ef98d3521cb386c425d43dd36d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59e374ef98d3521cb386c425d43dd36d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga59e374ef98d3521cb386c425d43dd36d">NRF_USBD_EP_DIR_OUT</a>&#160;&#160;&#160;(0U &lt;&lt; 7)</td></tr>
<tr class="memdesc:ga59e374ef98d3521cb386c425d43dd36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of direction bit for the OUT endpoint direction. <br/></td></tr>
<tr class="separator:ga59e374ef98d3521cb386c425d43dd36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9be1e5cf3c38d21e1116c2771ab86bcf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga9be1e5cf3c38d21e1116c2771ab86bcf">NRF_USBD_EPIN</a>(epnr)&#160;&#160;&#160;(((uint8_t)(epnr)) | <a class="el" href="group__nrf__usbd__hal.html#ga6357a6cf3e265f3f1c40077582cdc814">NRF_USBD_EP_DIR_IN</a>)</td></tr>
<tr class="memdesc:ga9be1e5cf3c38d21e1116c2771ab86bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for making the IN endpoint identifier from endpoint number.  <a href="#ga9be1e5cf3c38d21e1116c2771ab86bcf">More...</a><br/></td></tr>
<tr class="separator:ga9be1e5cf3c38d21e1116c2771ab86bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b6d96a8d69d5283919896d6f5b54b01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga8b6d96a8d69d5283919896d6f5b54b01">NRF_USBD_EPOUT</a>(epnr)&#160;&#160;&#160;(((uint8_t)(epnr)) | <a class="el" href="group__nrf__usbd__hal.html#ga59e374ef98d3521cb386c425d43dd36d">NRF_USBD_EP_DIR_OUT</a>)</td></tr>
<tr class="memdesc:ga8b6d96a8d69d5283919896d6f5b54b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for making the OUT endpoint identifier from endpoint number.  <a href="#ga8b6d96a8d69d5283919896d6f5b54b01">More...</a><br/></td></tr>
<tr class="separator:ga8b6d96a8d69d5283919896d6f5b54b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab94e2e9074a572f025cbbbbfb49852ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gab94e2e9074a572f025cbbbbfb49852ad">NRF_USBD_EP_NR_GET</a>(ep)&#160;&#160;&#160;((uint8_t)(((uint8_t)(ep)) &amp; 0xFU))</td></tr>
<tr class="memdesc:gab94e2e9074a572f025cbbbbfb49852ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for extracting the endpoint number from the specified endpoint identifier.  <a href="#gab94e2e9074a572f025cbbbbfb49852ad">More...</a><br/></td></tr>
<tr class="separator:gab94e2e9074a572f025cbbbbfb49852ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d429071b3003910f7aa3027fc2597d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga3d429071b3003910f7aa3027fc2597d6">NRF_USBD_EPIN_CHECK</a>(ep)&#160;&#160;&#160;( (((uint8_t)(ep)) &amp; <a class="el" href="group__nrf__usbd__hal.html#gafab440dd7f6a642c240348da60092eb3">NRF_USBD_EP_DIR_Msk</a>) == <a class="el" href="group__nrf__usbd__hal.html#ga6357a6cf3e265f3f1c40077582cdc814">NRF_USBD_EP_DIR_IN</a>  )</td></tr>
<tr class="memdesc:ga3d429071b3003910f7aa3027fc2597d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for checking the endpoint direction.  <a href="#ga3d429071b3003910f7aa3027fc2597d6">More...</a><br/></td></tr>
<tr class="separator:ga3d429071b3003910f7aa3027fc2597d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ed152cfe989b125a93a2687d8f7eae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gaa3ed152cfe989b125a93a2687d8f7eae">NRF_USBD_EPOUT_CHECK</a>(ep)&#160;&#160;&#160;( (((uint8_t)(ep)) &amp; <a class="el" href="group__nrf__usbd__hal.html#gafab440dd7f6a642c240348da60092eb3">NRF_USBD_EP_DIR_Msk</a>) == <a class="el" href="group__nrf__usbd__hal.html#ga59e374ef98d3521cb386c425d43dd36d">NRF_USBD_EP_DIR_OUT</a> )</td></tr>
<tr class="memdesc:gaa3ed152cfe989b125a93a2687d8f7eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for checking endpoint direction.  <a href="#gaa3ed152cfe989b125a93a2687d8f7eae">More...</a><br/></td></tr>
<tr class="separator:gaa3ed152cfe989b125a93a2687d8f7eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47229aa88f189c973e6c93a942772a10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga47229aa88f189c973e6c93a942772a10">NRF_USBD_EPISO_CHECK</a>(ep)&#160;&#160;&#160;(<a class="el" href="group__nrf__usbd__hal.html#gab94e2e9074a572f025cbbbbfb49852ad">NRF_USBD_EP_NR_GET</a>(ep) &gt;= <a class="el" href="group__nrf__usbd__hal.html#ga2885b53c22521a2a3e2dbcda0dd0f044">NRF_USBD_EPISO_FIRST</a>)</td></tr>
<tr class="memdesc:ga47229aa88f189c973e6c93a942772a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for checking if endpoint is isochronous.  <a href="#ga47229aa88f189c973e6c93a942772a10">More...</a><br/></td></tr>
<tr class="separator:ga47229aa88f189c973e6c93a942772a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5517794f8da667831ee7a22bd476a4e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga5517794f8da667831ee7a22bd476a4e3">NRF_USBD_EP_VALIDATE</a>(ep)</td></tr>
<tr class="memdesc:ga5517794f8da667831ee7a22bd476a4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for checking if given number is valid endpoint number.  <a href="#ga5517794f8da667831ee7a22bd476a4e3">More...</a><br/></td></tr>
<tr class="separator:ga5517794f8da667831ee7a22bd476a4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8241e0e42223e58adb98e2fb7b71a3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gae8241e0e42223e58adb98e2fb7b71a3f">NRF_USBD_EPISOOUT_NO_DATA</a>&#160;&#160;&#160;((size_t)(-1))</td></tr>
<tr class="memdesc:gae8241e0e42223e58adb98e2fb7b71a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not isochronous data frame received.  <a href="#gae8241e0e42223e58adb98e2fb7b71a3f">More...</a><br/></td></tr>
<tr class="separator:gae8241e0e42223e58adb98e2fb7b71a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gacef518da985b1dea4e65fb035cc3ffb7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gacef518da985b1dea4e65fb035cc3ffb7">nrf_usbd_task_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7aaa692795b5120e01bf399355bf90c18c">NRF_USBD_TASK_STARTEPIN0</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPIN[0] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a47bbcd684ff4a662d5ef07efbca96c7d">NRF_USBD_TASK_STARTEPIN1</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPIN[1] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a0ab46fe3aca622bb2dbeef5237433e42">NRF_USBD_TASK_STARTEPIN2</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPIN[2] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a2814d3219dd0804b7287411f30f91ead">NRF_USBD_TASK_STARTEPIN3</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPIN[3] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7ae804a47cbdd93d97696bfd18c36a94ee">NRF_USBD_TASK_STARTEPIN4</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPIN[4] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7af6e7f1750309ae67fe20f3032af514b9">NRF_USBD_TASK_STARTEPIN5</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPIN[5] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7ad26ab7b45ef225a275e8d239cf0cedf1">NRF_USBD_TASK_STARTEPIN6</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPIN[6] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7ae5181a7dab48989bbe300e67a26703cd">NRF_USBD_TASK_STARTEPIN7</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPIN[7] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a0907bfacd52e75c55970b06b40c6f1d6">NRF_USBD_TASK_STARTISOIN</a> = offsetof(NRF_USBD_Type, TASKS_STARTISOIN ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a3a2aa3531997cacc5c710f0b6a3a8bca">NRF_USBD_TASK_STARTEPOUT0</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPOUT[0]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7aeff7635ea0a9fc83aa4533927c2cb12d">NRF_USBD_TASK_STARTEPOUT1</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPOUT[1]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a6ac488aaacf506e91c384e41406254bb">NRF_USBD_TASK_STARTEPOUT2</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPOUT[2]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7ac1afd870aca0d6f544cd7f8c8dec77b8">NRF_USBD_TASK_STARTEPOUT3</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPOUT[3]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a6c070678faad2173be91ecf9c130d803">NRF_USBD_TASK_STARTEPOUT4</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPOUT[4]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a6082df80a2229390a497b6a7ad8eaf50">NRF_USBD_TASK_STARTEPOUT5</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPOUT[5]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7adcda72f0323184b6daa5be2cdf2c8300">NRF_USBD_TASK_STARTEPOUT6</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPOUT[6]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7aea65678c751ab58f6fed90df07ebf70e">NRF_USBD_TASK_STARTEPOUT7</a> = offsetof(NRF_USBD_Type, TASKS_STARTEPOUT[7]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7ab1d149e5b95fbb7297a22e196222cb36">NRF_USBD_TASK_STARTISOOUT</a> = offsetof(NRF_USBD_Type, TASKS_STARTISOOUT ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a4972fc44d7c126e2d70108582c6808d5">NRF_USBD_TASK_EP0RCVOUT</a> = offsetof(NRF_USBD_Type, TASKS_EP0RCVOUT ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a52811cb45db47f85042ab844929e8638">NRF_USBD_TASK_EP0STATUS</a> = offsetof(NRF_USBD_Type, TASKS_EP0STATUS ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7ad4a98ee0874ff4f64285dbbebf258bd9">NRF_USBD_TASK_EP0STALL</a> = offsetof(NRF_USBD_Type, TASKS_EP0STALL ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7ac9ba27e40be0a06543e210ae50915cca">NRF_USBD_TASK_DRIVEDPDM</a> = offsetof(NRF_USBD_Type, TASKS_DPDMDRIVE ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a3344ae7c97a03e4c3a24c456f13f50e2">NRF_USBD_TASK_NODRIVEDPDM</a> = offsetof(NRF_USBD_Type, TASKS_DPDMNODRIVE )
<br/>
 }</td></tr>
<tr class="memdesc:gacef518da985b1dea4e65fb035cc3ffb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD tasks.  <a href="group__nrf__usbd__hal.html#gacef518da985b1dea4e65fb035cc3ffb7">More...</a><br/></td></tr>
<tr class="separator:gacef518da985b1dea4e65fb035cc3ffb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0187f1cfcba4bbd00158f9b04ec06fe6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6af83cb0aff273a343ea398411ec6e1537">NRF_USBD_EVENT_USBRESET</a> = offsetof(NRF_USBD_Type, EVENTS_USBRESET ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6ae841c340feff31143770e2b3384a12fb">NRF_USBD_EVENT_STARTED</a> = offsetof(NRF_USBD_Type, EVENTS_STARTED ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6ad04c0755ec5ce1eafe1a12e46c898822">NRF_USBD_EVENT_ENDEPIN0</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPIN[0] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a658cd1bb7e3c3e6f9ea2c9311e0e3162">NRF_USBD_EVENT_ENDEPIN1</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPIN[1] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a2145cb9e6a9f5de4a3ccc0f323b7de3d">NRF_USBD_EVENT_ENDEPIN2</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPIN[2] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a28a65e73e6e125682f483734fdbeb238">NRF_USBD_EVENT_ENDEPIN3</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPIN[3] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a917c50a3234d56030ef445541dda9141">NRF_USBD_EVENT_ENDEPIN4</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPIN[4] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a28b6c47ec54fccae0dcbab0bc332ce28">NRF_USBD_EVENT_ENDEPIN5</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPIN[5] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a1ece33d3fd52f5dd11e82f4a40ba9c42">NRF_USBD_EVENT_ENDEPIN6</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPIN[6] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a24ede0a7230ba2f6705c5594963db249">NRF_USBD_EVENT_ENDEPIN7</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPIN[7] ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a5d8be992cabec77f4753060597a1eddc">NRF_USBD_EVENT_EP0DATADONE</a> = offsetof(NRF_USBD_Type, EVENTS_EP0DATADONE), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a5f870f773392a17f08d9494d7c8f10c6">NRF_USBD_EVENT_ENDISOIN0</a> = offsetof(NRF_USBD_Type, EVENTS_ENDISOIN ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6ad5936ba41dfccd2915fc0e2ec3a887bd">NRF_USBD_EVENT_ENDEPOUT0</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPOUT[0]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6af21e07f0978c2fbeb063a8ae6155276d">NRF_USBD_EVENT_ENDEPOUT1</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPOUT[1]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6abf3746cb4bdbd6e337d9c6c8fd38e6af">NRF_USBD_EVENT_ENDEPOUT2</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPOUT[2]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6aa9f75a485be35880d29c84ab369e9c7b">NRF_USBD_EVENT_ENDEPOUT3</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPOUT[3]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a612f10f64675333dffb9fe6b5823e377">NRF_USBD_EVENT_ENDEPOUT4</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPOUT[4]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6acca649675f717f169d01aaad0b919f0d">NRF_USBD_EVENT_ENDEPOUT5</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPOUT[5]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a10187f674c06474e4370bca5e4b6df18">NRF_USBD_EVENT_ENDEPOUT6</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPOUT[6]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6adf9facfc2406fe5808076c8751d6f2b0">NRF_USBD_EVENT_ENDEPOUT7</a> = offsetof(NRF_USBD_Type, EVENTS_ENDEPOUT[7]), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a4bbee040b5f6b31a32febdbf90bad881">NRF_USBD_EVENT_ENDISOOUT0</a> = offsetof(NRF_USBD_Type, EVENTS_ENDISOOUT ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6ae3cb91560fe95b107f7e7e324ecc69af">NRF_USBD_EVENT_SOF</a> = offsetof(NRF_USBD_Type, EVENTS_SOF ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6a4dd28ded5479d8b579e4641aa486af00">NRF_USBD_EVENT_USBEVENT</a> = offsetof(NRF_USBD_Type, EVENTS_USBEVENT ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6ac660ce8ed22d201c0af693732a218026">NRF_USBD_EVENT_EP0SETUP</a> = offsetof(NRF_USBD_Type, EVENTS_EP0SETUP ), 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga0187f1cfcba4bbd00158f9b04ec06fe6aad1c28abf725d8d615738836e651c24c">NRF_USBD_EVENT_DATAEP</a> = offsetof(NRF_USBD_Type, EVENTS_EPDATA )
<br/>
 }</td></tr>
<tr class="memdesc:ga0187f1cfcba4bbd00158f9b04ec06fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD events.  <a href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">More...</a><br/></td></tr>
<tr class="separator:ga0187f1cfcba4bbd00158f9b04ec06fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdd0cd13c3c89afb8a05dae04306a81f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gafdd0cd13c3c89afb8a05dae04306a81f">nrf_usbd_short_mask_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggafdd0cd13c3c89afb8a05dae04306a81fa1b7356a0a28ca3d52198b78ad6fefe4c">NRF_USBD_SHORT_EP0DATADONE_STARTEPIN0_MASK</a> = USBD_SHORTS_EP0DATADONE_STARTEPIN0_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggafdd0cd13c3c89afb8a05dae04306a81fa0b3f874c1ef8311e523b801fadd4b3e9">NRF_USBD_SHORT_EP0DATADONE_STARTEPOUT0_MASK</a> = USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggafdd0cd13c3c89afb8a05dae04306a81fa81e66f5768d57e60244893d93c1d3bc8">NRF_USBD_SHORT_EP0DATADONE_EP0STATUS_MASK</a> = USBD_SHORTS_EP0DATADONE_EP0STATUS_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggafdd0cd13c3c89afb8a05dae04306a81fad0617183c52a6bb7ca15c4e36b3d6e38">NRF_USBD_SHORT_ENDEPOUT0_EP0STATUS_MASK</a> = USBD_SHORTS_ENDEPOUT0_EP0STATUS_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggafdd0cd13c3c89afb8a05dae04306a81fa1d863080219bf895b1e723b8201fb2a9">NRF_USBD_SHORT_ENDEPOUT0_EP0RCVOUT_MASK</a> = USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Msk
<br/>
 }</td></tr>
<tr class="memdesc:gafdd0cd13c3c89afb8a05dae04306a81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD shorts.  <a href="group__nrf__usbd__hal.html#gafdd0cd13c3c89afb8a05dae04306a81f">More...</a><br/></td></tr>
<tr class="separator:gafdd0cd13c3c89afb8a05dae04306a81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb0886b59ca193e84b9405ea55444e99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gabb0886b59ca193e84b9405ea55444e99">nrf_usbd_int_mask_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99ac37d68fdbd9aef08827ce94b49330ad7">NRF_USBD_INT_USBRESET_MASK</a> = USBD_INTEN_USBRESET_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99ada4192c314b47c030ca33d8c4e586305">NRF_USBD_INT_STARTED_MASK</a> = USBD_INTEN_STARTED_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99af575309faaea4de9909ee01d1da6debb">NRF_USBD_INT_ENDEPIN0_MASK</a> = USBD_INTEN_ENDEPIN0_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99ae5422bd3dce7ac7c604a82c56c565fba">NRF_USBD_INT_ENDEPIN1_MASK</a> = USBD_INTEN_ENDEPIN1_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99ae6dd16ba2e80c5d6e42b28925f214e53">NRF_USBD_INT_ENDEPIN2_MASK</a> = USBD_INTEN_ENDEPIN2_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a6fa982339a54bc3a3dd70ee379033a68">NRF_USBD_INT_ENDEPIN3_MASK</a> = USBD_INTEN_ENDEPIN3_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a47f1b11f42f5fabd892f23ef98917b43">NRF_USBD_INT_ENDEPIN4_MASK</a> = USBD_INTEN_ENDEPIN4_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99accdc728d1dd0ffb3aa683b2d1dcb1126">NRF_USBD_INT_ENDEPIN5_MASK</a> = USBD_INTEN_ENDEPIN5_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a90c66c4312063be527effed166ef0189">NRF_USBD_INT_ENDEPIN6_MASK</a> = USBD_INTEN_ENDEPIN6_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99afd0bbd63552837726376b0294c1ec614">NRF_USBD_INT_ENDEPIN7_MASK</a> = USBD_INTEN_ENDEPIN7_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a748b2373c4e31c7b325bf21ec76cb0f4">NRF_USBD_INT_EP0DATADONE_MASK</a> = USBD_INTEN_EP0DATADONE_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a880f7153500a33e64bdc99d47281d18e">NRF_USBD_INT_ENDISOIN0_MASK</a> = USBD_INTEN_ENDISOIN_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a5bd2330fe36dd832277019d9486c1120">NRF_USBD_INT_ENDEPOUT0_MASK</a> = USBD_INTEN_ENDEPOUT0_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99ac38bd0cd841901151c1b6454b27a4e06">NRF_USBD_INT_ENDEPOUT1_MASK</a> = USBD_INTEN_ENDEPOUT1_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a9e00b89329eff80a86818b090a174d09">NRF_USBD_INT_ENDEPOUT2_MASK</a> = USBD_INTEN_ENDEPOUT2_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a76a9c94091a0e32af6d059bdfbdca865">NRF_USBD_INT_ENDEPOUT3_MASK</a> = USBD_INTEN_ENDEPOUT3_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99aa2151d91bb090113401dfd2c83d491d3">NRF_USBD_INT_ENDEPOUT4_MASK</a> = USBD_INTEN_ENDEPOUT4_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a767506405908faf164481e4db334484a">NRF_USBD_INT_ENDEPOUT5_MASK</a> = USBD_INTEN_ENDEPOUT5_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a3fca2864d752b289e59be96918792298">NRF_USBD_INT_ENDEPOUT6_MASK</a> = USBD_INTEN_ENDEPOUT6_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99ab115f6cb829a6b69c5a89c23ddef6ecf">NRF_USBD_INT_ENDEPOUT7_MASK</a> = USBD_INTEN_ENDEPOUT7_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a241af2b50bf2876d78573d5eae0e2770">NRF_USBD_INT_ENDISOOUT0_MASK</a> = USBD_INTEN_ENDISOOUT_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a234d4ad6a36d8a9e04b4f1d09ac79540">NRF_USBD_INT_SOF_MASK</a> = USBD_INTEN_SOF_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a455c86aa80aa62952865aef26ca3ec6f">NRF_USBD_INT_USBEVENT_MASK</a> = USBD_INTEN_USBEVENT_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99a596911d01498576994e83241e979d4e5">NRF_USBD_INT_EP0SETUP_MASK</a> = USBD_INTEN_EP0SETUP_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggabb0886b59ca193e84b9405ea55444e99ade8a86638b6c4777f261671ac4a72dca">NRF_USBD_INT_DATAEP_MASK</a> = USBD_INTEN_EPDATA_Msk
<br/>
 }</td></tr>
<tr class="memdesc:gabb0886b59ca193e84b9405ea55444e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD interrupts.  <a href="group__nrf__usbd__hal.html#gabb0886b59ca193e84b9405ea55444e99">More...</a><br/></td></tr>
<tr class="separator:gabb0886b59ca193e84b9405ea55444e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8588a7f666e82f6c441046d924ff197e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga8588a7f666e82f6c441046d924ff197e">nrf_usbd_eventcause_mask_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga8588a7f666e82f6c441046d924ff197ea526a378a0bce39373b3521252a404dab">NRF_USBD_EVENTCAUSE_ISOOUTCRC_MASK</a> = USBD_EVENTCAUSE_ISOOUTCRC_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga8588a7f666e82f6c441046d924ff197ea68761f3edd6f26802ec415c63315204d">NRF_USBD_EVENTCAUSE_SUSPEND_MASK</a> = USBD_EVENTCAUSE_SUSPEND_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga8588a7f666e82f6c441046d924ff197ea9774c93c16b0f8d3557e1794df33d608">NRF_USBD_EVENTCAUSE_RESUME_MASK</a> = USBD_EVENTCAUSE_RESUME_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga8588a7f666e82f6c441046d924ff197eaa71e0597c1c9ca8d665399d56a23b571">NRF_USBD_EVENTCAUSE_WUREQ_MASK</a> = USBD_EVENTCAUSE_USBWUALLOWED_Msk, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga8588a7f666e82f6c441046d924ff197ea124d310529b710dba2b27bbfeaa23468">NRF_USBD_EVENTCAUSE_READY_MASK</a> = USBD_EVENTCAUSE_READY_Msk
<br/>
 }</td></tr>
<tr class="memdesc:ga8588a7f666e82f6c441046d924ff197e"><td class="mdescLeft">&#160;</td><td class="mdescRight">EVENTCAUSE register bit masks.  <a href="group__nrf__usbd__hal.html#ga8588a7f666e82f6c441046d924ff197e">More...</a><br/></td></tr>
<tr class="separator:ga8588a7f666e82f6c441046d924ff197e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86af0982c97904e6f14200709346f93e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga86af0982c97904e6f14200709346f93e">nrf_usbd_dpdmvalue_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga86af0982c97904e6f14200709346f93eaa3bb7c1a49d424f6bdfe82463cb86abb">NRF_USBD_DPDMVALUE_RESUME</a> = USBD_DPDMVALUE_STATE_Resume, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga86af0982c97904e6f14200709346f93ea5a47d0fdb93688f7dee41660599df12b">NRF_USBD_DPDMVALUE_J</a> = USBD_DPDMVALUE_STATE_J, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga86af0982c97904e6f14200709346f93ea5e1e542f5c263ee2d74b5e53887bf7d6">NRF_USBD_DPMVALUE_K</a> = USBD_DPDMVALUE_STATE_K
<br/>
 }</td></tr>
<tr class="memdesc:ga86af0982c97904e6f14200709346f93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DPDMVALUE register.  <a href="group__nrf__usbd__hal.html#ga86af0982c97904e6f14200709346f93e">More...</a><br/></td></tr>
<tr class="separator:ga86af0982c97904e6f14200709346f93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7a52ea2795a7ec86d88d2479115e8ab"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gac7a52ea2795a7ec86d88d2479115e8ab">nrf_usbd_dtoggle_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggac7a52ea2795a7ec86d88d2479115e8abad544fd91f626686855661c029f6783ed">NRF_USBD_DTOGGLE_NOP</a> = USBD_DTOGGLE_VALUE_Nop, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggac7a52ea2795a7ec86d88d2479115e8aba840a6b8fd3f75337a0cf934631722bbe">NRF_USBD_DTOGGLE_DATA0</a> = USBD_DTOGGLE_VALUE_Data0, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#ggac7a52ea2795a7ec86d88d2479115e8aba1457b3fd3ca4bbcdcda2f124bd3bc4d7">NRF_USBD_DTOGGLE_DATA1</a> = USBD_DTOGGLE_VALUE_Data1
<br/>
 }</td></tr>
<tr class="memdesc:gac7a52ea2795a7ec86d88d2479115e8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data toggle value or operation.  <a href="group__nrf__usbd__hal.html#gac7a52ea2795a7ec86d88d2479115e8ab">More...</a><br/></td></tr>
<tr class="separator:gac7a52ea2795a7ec86d88d2479115e8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbdc3f9d30d220c792ee698ea3ab290e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gadbdc3f9d30d220c792ee698ea3ab290e">nrf_usbd_epstatus_mask_t</a> { <br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPIN0_MASK</b> = USBD_EPSTATUS_EPIN0_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPIN1_MASK</b> = USBD_EPSTATUS_EPIN1_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPIN2_MASK</b> = USBD_EPSTATUS_EPIN2_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPIN3_MASK</b> = USBD_EPSTATUS_EPIN3_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPIN4_MASK</b> = USBD_EPSTATUS_EPIN4_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPIN5_MASK</b> = USBD_EPSTATUS_EPIN5_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPIN6_MASK</b> = USBD_EPSTATUS_EPIN6_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPIN7_MASK</b> = USBD_EPSTATUS_EPIN7_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPOUT0_MASK</b> = USBD_EPSTATUS_EPOUT0_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPOUT1_MASK</b> = USBD_EPSTATUS_EPOUT1_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPOUT2_MASK</b> = USBD_EPSTATUS_EPOUT2_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPOUT3_MASK</b> = USBD_EPSTATUS_EPOUT3_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPOUT4_MASK</b> = USBD_EPSTATUS_EPOUT4_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPOUT5_MASK</b> = USBD_EPSTATUS_EPOUT5_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPOUT6_MASK</b> = USBD_EPSTATUS_EPOUT6_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPSTATUS_EPOUT7_MASK</b> = USBD_EPSTATUS_EPOUT7_Msk
<br/>
 }</td></tr>
<tr class="memdesc:gadbdc3f9d30d220c792ee698ea3ab290e"><td class="mdescLeft">&#160;</td><td class="mdescRight">EPSTATUS bit masks. <br/></td></tr>
<tr class="separator:gadbdc3f9d30d220c792ee698ea3ab290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf16119bd371d2d9bae89ffe785b8a08b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gaf16119bd371d2d9bae89ffe785b8a08b">nrf_usbd_dataepstatus_mask_t</a> { <br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPIN1_MASK</b> = USBD_EPDATASTATUS_EPIN1_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPIN2_MASK</b> = USBD_EPDATASTATUS_EPIN2_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPIN3_MASK</b> = USBD_EPDATASTATUS_EPIN3_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPIN4_MASK</b> = USBD_EPDATASTATUS_EPIN4_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPIN5_MASK</b> = USBD_EPDATASTATUS_EPIN5_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPIN6_MASK</b> = USBD_EPDATASTATUS_EPIN6_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPIN7_MASK</b> = USBD_EPDATASTATUS_EPIN7_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPOUT1_MASK</b> = USBD_EPDATASTATUS_EPOUT1_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPOUT2_MASK</b> = USBD_EPDATASTATUS_EPOUT2_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPOUT3_MASK</b> = USBD_EPDATASTATUS_EPOUT3_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPOUT4_MASK</b> = USBD_EPDATASTATUS_EPOUT4_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPOUT5_MASK</b> = USBD_EPDATASTATUS_EPOUT5_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPOUT6_MASK</b> = USBD_EPDATASTATUS_EPOUT6_Msk, 
<br/>
&#160;&#160;<b>NRF_USBD_EPDATASTATUS_EPOUT7_MASK</b> = USBD_EPDATASTATUS_EPOUT7_Msk
<br/>
 }</td></tr>
<tr class="memdesc:gaf16119bd371d2d9bae89ffe785b8a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">DATAEPSTATUS bit masks. <br/></td></tr>
<tr class="separator:gaf16119bd371d2d9bae89ffe785b8a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b397851455aff39727f26fa7f52a26c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga2b397851455aff39727f26fa7f52a26c">nrf_usbd_isosplit_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga2b397851455aff39727f26fa7f52a26ca75c5f68dab4ec2a06a61f5bedbde1b68">NRF_USBD_ISOSPLIT_ONEDIR</a> = USBD_ISOSPLIT_SPLIT_OneDir, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga2b397851455aff39727f26fa7f52a26cafa3a5cc6980ae430de05d2fa27941b58">NRF_USBD_ISOSPLIT_HALF</a> = USBD_ISOSPLIT_SPLIT_HalfIN
<br/>
 }</td></tr>
<tr class="memdesc:ga2b397851455aff39727f26fa7f52a26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISOSPLIT configurations.  <a href="group__nrf__usbd__hal.html#ga2b397851455aff39727f26fa7f52a26c">More...</a><br/></td></tr>
<tr class="separator:ga2b397851455aff39727f26fa7f52a26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2328f0becb99ca74db0490cd48af4861"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga2328f0becb99ca74db0490cd48af4861">nrf_usbd_isoinconfig_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga2328f0becb99ca74db0490cd48af4861af5220a5dd7d3def691031ebfc83e27be">NRF_USBD_ISOINCONFIG_NORESP</a> = USBD_ISOINCONFIG_RESPONSE_NoResp, 
<br/>
&#160;&#160;<a class="el" href="group__nrf__usbd__hal.html#gga2328f0becb99ca74db0490cd48af4861ac85cee2b3da471763645cfbf36bbbff5">NRF_USBD_ISOINCONFIG_ZERODATA</a> = USBD_ISOINCONFIG_RESPONSE_ZeroData
<br/>
 }</td></tr>
<tr class="memdesc:ga2328f0becb99ca74db0490cd48af4861"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISOINCONFIG configurations.  <a href="group__nrf__usbd__hal.html#ga2328f0becb99ca74db0490cd48af4861">More...</a><br/></td></tr>
<tr class="separator:ga2328f0becb99ca74db0490cd48af4861"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5b6305bb613dbbe0fa8fe0c946113053"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga5b6305bb613dbbe0fa8fe0c946113053">nrf_usbd_task_trigger</a> (NRF_USBD_Type *p_reg, <a class="el" href="group__nrf__usbd__hal.html#gacef518da985b1dea4e65fb035cc3ffb7">nrf_usbd_task_t</a> task)</td></tr>
<tr class="memdesc:ga5b6305bb613dbbe0fa8fe0c946113053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for activating the specified USBD task.  <a href="#ga5b6305bb613dbbe0fa8fe0c946113053">More...</a><br/></td></tr>
<tr class="separator:ga5b6305bb613dbbe0fa8fe0c946113053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d91d10e21fdcd9e9256eb2ac99db807"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga5d91d10e21fdcd9e9256eb2ac99db807">nrf_usbd_task_address_get</a> (NRF_USBD_Type const *p_reg, <a class="el" href="group__nrf__usbd__hal.html#gacef518da985b1dea4e65fb035cc3ffb7">nrf_usbd_task_t</a> task)</td></tr>
<tr class="memdesc:ga5d91d10e21fdcd9e9256eb2ac99db807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of the specified USBD task register.  <a href="#ga5d91d10e21fdcd9e9256eb2ac99db807">More...</a><br/></td></tr>
<tr class="separator:ga5d91d10e21fdcd9e9256eb2ac99db807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3766f49d2d34f7e5bd7a39e2c4cc030"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gad3766f49d2d34f7e5bd7a39e2c4cc030">nrf_usbd_event_clear</a> (NRF_USBD_Type *p_reg, <a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a> event)</td></tr>
<tr class="memdesc:gad3766f49d2d34f7e5bd7a39e2c4cc030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for clearing the specified event.  <a href="#gad3766f49d2d34f7e5bd7a39e2c4cc030">More...</a><br/></td></tr>
<tr class="separator:gad3766f49d2d34f7e5bd7a39e2c4cc030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819a09be036542e509f2fcceccf18c86"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga819a09be036542e509f2fcceccf18c86">nrf_usbd_event_check</a> (NRF_USBD_Type const *p_reg, <a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a> event)</td></tr>
<tr class="memdesc:ga819a09be036542e509f2fcceccf18c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving the state of the USBD event.  <a href="#ga819a09be036542e509f2fcceccf18c86">More...</a><br/></td></tr>
<tr class="separator:ga819a09be036542e509f2fcceccf18c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ba54cb078b7ac770ab19407d2dd5b5e"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga6ba54cb078b7ac770ab19407d2dd5b5e">nrf_usbd_event_get_and_clear</a> (NRF_USBD_Type *p_reg, <a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a> event)</td></tr>
<tr class="memdesc:ga6ba54cb078b7ac770ab19407d2dd5b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting and clearing the state of the specified event.  <a href="#ga6ba54cb078b7ac770ab19407d2dd5b5e">More...</a><br/></td></tr>
<tr class="separator:ga6ba54cb078b7ac770ab19407d2dd5b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d89568dfc90f11a13cc4ec011614a1"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gaa8d89568dfc90f11a13cc4ec011614a1">nrf_usbd_event_address_get</a> (NRF_USBD_Type const *p_reg, <a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a> event)</td></tr>
<tr class="memdesc:gaa8d89568dfc90f11a13cc4ec011614a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of the specified USBD event register.  <a href="#gaa8d89568dfc90f11a13cc4ec011614a1">More...</a><br/></td></tr>
<tr class="separator:gaa8d89568dfc90f11a13cc4ec011614a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga848a66d0f7750d3c112c6e273b63eab0"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga848a66d0f7750d3c112c6e273b63eab0">nrf_usbd_shorts_enable</a> (NRF_USBD_Type *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:ga848a66d0f7750d3c112c6e273b63eab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting shortcuts.  <a href="#ga848a66d0f7750d3c112c6e273b63eab0">More...</a><br/></td></tr>
<tr class="separator:ga848a66d0f7750d3c112c6e273b63eab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc4c421f2458cdaca584f38f19fc373"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga2fc4c421f2458cdaca584f38f19fc373">nrf_usbd_shorts_disable</a> (NRF_USBD_Type *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:ga2fc4c421f2458cdaca584f38f19fc373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for clearing shortcuts.  <a href="#ga2fc4c421f2458cdaca584f38f19fc373">More...</a><br/></td></tr>
<tr class="separator:ga2fc4c421f2458cdaca584f38f19fc373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fdfbd1cac43daab01d95d68403799c7"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga4fdfbd1cac43daab01d95d68403799c7">nrf_usbd_shorts_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga4fdfbd1cac43daab01d95d68403799c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the shortcut mask.  <a href="#ga4fdfbd1cac43daab01d95d68403799c7">More...</a><br/></td></tr>
<tr class="separator:ga4fdfbd1cac43daab01d95d68403799c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8394a8e2a2238621dd641533827e904"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gab8394a8e2a2238621dd641533827e904">nrf_usbd_int_enable</a> (NRF_USBD_Type *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:gab8394a8e2a2238621dd641533827e904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the selected interrupts.  <a href="#gab8394a8e2a2238621dd641533827e904">More...</a><br/></td></tr>
<tr class="separator:gab8394a8e2a2238621dd641533827e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc0de9e2275bb65dd566400f45ac73f2"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gacc0de9e2275bb65dd566400f45ac73f2">nrf_usbd_int_enable_check</a> (NRF_USBD_Type const *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:gacc0de9e2275bb65dd566400f45ac73f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if the specified interrupts are enabled.  <a href="#gacc0de9e2275bb65dd566400f45ac73f2">More...</a><br/></td></tr>
<tr class="separator:gacc0de9e2275bb65dd566400f45ac73f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66829e1a9cd3920b2ff5b17fb3d39569"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga66829e1a9cd3920b2ff5b17fb3d39569">nrf_usbd_int_enable_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga66829e1a9cd3920b2ff5b17fb3d39569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving the information about the enabled interrupts.  <a href="#ga66829e1a9cd3920b2ff5b17fb3d39569">More...</a><br/></td></tr>
<tr class="separator:ga66829e1a9cd3920b2ff5b17fb3d39569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ac25b07069e1509d8005c56902f1fd"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga71ac25b07069e1509d8005c56902f1fd">nrf_usbd_int_disable</a> (NRF_USBD_Type *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:ga71ac25b07069e1509d8005c56902f1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling the selected interrupts.  <a href="#ga71ac25b07069e1509d8005c56902f1fd">More...</a><br/></td></tr>
<tr class="separator:ga71ac25b07069e1509d8005c56902f1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562e57247a2d9890b9468d0bd73e10ed"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga562e57247a2d9890b9468d0bd73e10ed">nrf_usbd_enable</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:ga562e57247a2d9890b9468d0bd73e10ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the USBD.  <a href="#ga562e57247a2d9890b9468d0bd73e10ed">More...</a><br/></td></tr>
<tr class="separator:ga562e57247a2d9890b9468d0bd73e10ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga560e5d2709b79666577a22053b29d257"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga560e5d2709b79666577a22053b29d257">nrf_usbd_disable</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:ga560e5d2709b79666577a22053b29d257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling the USBD.  <a href="#ga560e5d2709b79666577a22053b29d257">More...</a><br/></td></tr>
<tr class="separator:ga560e5d2709b79666577a22053b29d257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9e732f036188c7bcffd40e1af8ddfb"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga6d9e732f036188c7bcffd40e1af8ddfb">nrf_usbd_eventcause_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga6d9e732f036188c7bcffd40e1af8ddfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the EVENTCAUSE register.  <a href="#ga6d9e732f036188c7bcffd40e1af8ddfb">More...</a><br/></td></tr>
<tr class="separator:ga6d9e732f036188c7bcffd40e1af8ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09314d6cf8bf067c28c4be5f6f900ee9"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga09314d6cf8bf067c28c4be5f6f900ee9">nrf_usbd_eventcause_clear</a> (NRF_USBD_Type *p_reg, uint32_t flags)</td></tr>
<tr class="memdesc:ga09314d6cf8bf067c28c4be5f6f900ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for clearing the EVENTCAUSE flags.  <a href="#ga09314d6cf8bf067c28c4be5f6f900ee9">More...</a><br/></td></tr>
<tr class="separator:ga09314d6cf8bf067c28c4be5f6f900ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbf646da698addceb7fccbf6f19562d"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gafdbf646da698addceb7fccbf6f19562d">nrf_usbd_eventcause_get_and_clear</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:gafdbf646da698addceb7fccbf6f19562d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the EVENTCAUSE register and clearing flags that are set.  <a href="#gafdbf646da698addceb7fccbf6f19562d">More...</a><br/></td></tr>
<tr class="separator:gafdbf646da698addceb7fccbf6f19562d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b4a86b907d9d16354916efa13c913f4"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga4b4a86b907d9d16354916efa13c913f4">nrf_usbd_halted_get</a> (NRF_USBD_Type const *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:ga4b4a86b907d9d16354916efa13c913f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the HALTEDEPIN register value.  <a href="#ga4b4a86b907d9d16354916efa13c913f4">More...</a><br/></td></tr>
<tr class="separator:ga4b4a86b907d9d16354916efa13c913f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a606967bf03d76c70bf22552a94617"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gae6a606967bf03d76c70bf22552a94617">nrf_usbd_ep_is_stall</a> (NRF_USBD_Type const *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:gae6a606967bf03d76c70bf22552a94617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking whether the selected endpoint is stalled.  <a href="#gae6a606967bf03d76c70bf22552a94617">More...</a><br/></td></tr>
<tr class="separator:gae6a606967bf03d76c70bf22552a94617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf521fe906e06186dc3b1633cd334d0"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga6bf521fe906e06186dc3b1633cd334d0">nrf_usbd_epstatus_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga6bf521fe906e06186dc3b1633cd334d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting EPSTATUS register value.  <a href="#ga6bf521fe906e06186dc3b1633cd334d0">More...</a><br/></td></tr>
<tr class="separator:ga6bf521fe906e06186dc3b1633cd334d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aad5300a3ad73ce92b98a123282c714"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga8aad5300a3ad73ce92b98a123282c714">nrf_usbd_epstatus_clear</a> (NRF_USBD_Type *p_reg, uint32_t flags)</td></tr>
<tr class="memdesc:ga8aad5300a3ad73ce92b98a123282c714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for clearing EPSTATUS register value.  <a href="#ga8aad5300a3ad73ce92b98a123282c714">More...</a><br/></td></tr>
<tr class="separator:ga8aad5300a3ad73ce92b98a123282c714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a2a0466ceee8179df9d7d3a7e865ad"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gac1a2a0466ceee8179df9d7d3a7e865ad">nrf_usbd_epstatus_get_and_clear</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:gac1a2a0466ceee8179df9d7d3a7e865ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting and clearing EPSTATUS register value.  <a href="#gac1a2a0466ceee8179df9d7d3a7e865ad">More...</a><br/></td></tr>
<tr class="separator:gac1a2a0466ceee8179df9d7d3a7e865ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23746eeddcdc074aa2639fe406212a3e"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga23746eeddcdc074aa2639fe406212a3e">nrf_usbd_epdatastatus_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga23746eeddcdc074aa2639fe406212a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting DATAEPSTATUS register value.  <a href="#ga23746eeddcdc074aa2639fe406212a3e">More...</a><br/></td></tr>
<tr class="separator:ga23746eeddcdc074aa2639fe406212a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga165b2891148dc620c4105f1b430832ca"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga165b2891148dc620c4105f1b430832ca">nrf_usbd_epdatastatus_clear</a> (NRF_USBD_Type *p_reg, uint32_t flags)</td></tr>
<tr class="memdesc:ga165b2891148dc620c4105f1b430832ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for clearing DATAEPSTATUS register value.  <a href="#ga165b2891148dc620c4105f1b430832ca">More...</a><br/></td></tr>
<tr class="separator:ga165b2891148dc620c4105f1b430832ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa04941d3bcefa5119bc69ec39cb259"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gadfa04941d3bcefa5119bc69ec39cb259">nrf_usbd_epdatastatus_get_and_clear</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:gadfa04941d3bcefa5119bc69ec39cb259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting and clearing DATAEPSTATUS register value.  <a href="#gadfa04941d3bcefa5119bc69ec39cb259">More...</a><br/></td></tr>
<tr class="separator:gadfa04941d3bcefa5119bc69ec39cb259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484d691a3f3ac383b700cafe2b2d2ad2"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga484d691a3f3ac383b700cafe2b2d2ad2">nrf_usbd_epout_size_get</a> (NRF_USBD_Type const *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:ga484d691a3f3ac383b700cafe2b2d2ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the number of received bytes on the selected endpoint.  <a href="#ga484d691a3f3ac383b700cafe2b2d2ad2">More...</a><br/></td></tr>
<tr class="separator:ga484d691a3f3ac383b700cafe2b2d2ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781e617b1d8866be26f485f3b7f8320f"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga781e617b1d8866be26f485f3b7f8320f">nrf_usbd_episoout_size_get</a> (NRF_USBD_Type const *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:ga781e617b1d8866be26f485f3b7f8320f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting number of the received bytes on isochronous endpoint.  <a href="#ga781e617b1d8866be26f485f3b7f8320f">More...</a><br/></td></tr>
<tr class="separator:ga781e617b1d8866be26f485f3b7f8320f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf64d7d3c97e6dd3f6cfd0ba8b5297ca2"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gaf64d7d3c97e6dd3f6cfd0ba8b5297ca2">nrf_usbd_epout_clear</a> (NRF_USBD_Type *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:gaf64d7d3c97e6dd3f6cfd0ba8b5297ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for clearing OUT endpoint to accept any new incoming traffic.  <a href="#gaf64d7d3c97e6dd3f6cfd0ba8b5297ca2">More...</a><br/></td></tr>
<tr class="separator:gaf64d7d3c97e6dd3f6cfd0ba8b5297ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde4d643e37439183c87b23d9a3a077a"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gacde4d643e37439183c87b23d9a3a077a">nrf_usbd_pullup_enable</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:gacde4d643e37439183c87b23d9a3a077a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the USB pullup.  <a href="#gacde4d643e37439183c87b23d9a3a077a">More...</a><br/></td></tr>
<tr class="separator:gacde4d643e37439183c87b23d9a3a077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf52b8f824fcdcb9ff10aaaecdfcabe5"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gabf52b8f824fcdcb9ff10aaaecdfcabe5">nrf_usbd_pullup_disable</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:gabf52b8f824fcdcb9ff10aaaecdfcabe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling the USB pullup.  <a href="#gabf52b8f824fcdcb9ff10aaaecdfcabe5">More...</a><br/></td></tr>
<tr class="separator:gabf52b8f824fcdcb9ff10aaaecdfcabe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c4627bb70c2fdaf5f5e65edca4e2739"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga0c4627bb70c2fdaf5f5e65edca4e2739">nrf_usbd_pullup_check</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga0c4627bb70c2fdaf5f5e65edca4e2739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the current the USB pullup state.  <a href="#ga0c4627bb70c2fdaf5f5e65edca4e2739">More...</a><br/></td></tr>
<tr class="separator:ga0c4627bb70c2fdaf5f5e65edca4e2739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0f369fe4c04df616590d69487339c5"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga3f0f369fe4c04df616590d69487339c5">nrf_usbd_dpdmvalue_set</a> (NRF_USBD_Type *p_reg, <a class="el" href="group__nrf__usbd__hal.html#ga86af0982c97904e6f14200709346f93e">nrf_usbd_dpdmvalue_t</a> val)</td></tr>
<tr class="memdesc:ga3f0f369fe4c04df616590d69487339c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for configuring the value to be forced on the bus on the DRIVEDPDM task.  <a href="#ga3f0f369fe4c04df616590d69487339c5">More...</a><br/></td></tr>
<tr class="separator:ga3f0f369fe4c04df616590d69487339c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b7f36031cd0ae233d609ab390eae84"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga60b7f36031cd0ae233d609ab390eae84">nrf_usbd_dtoggle_set</a> (NRF_USBD_Type *p_reg, uint8_t ep, <a class="el" href="group__nrf__usbd__hal.html#gac7a52ea2795a7ec86d88d2479115e8ab">nrf_usbd_dtoggle_t</a> op)</td></tr>
<tr class="memdesc:ga60b7f36031cd0ae233d609ab390eae84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting the data toggle.  <a href="#ga60b7f36031cd0ae233d609ab390eae84">More...</a><br/></td></tr>
<tr class="separator:ga60b7f36031cd0ae233d609ab390eae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c270f17c425d5d9c844aed147e973a9"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE <br class="typebreak"/>
<a class="el" href="group__nrf__usbd__hal.html#gac7a52ea2795a7ec86d88d2479115e8ab">nrf_usbd_dtoggle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga1c270f17c425d5d9c844aed147e973a9">nrf_usbd_dtoggle_get</a> (NRF_USBD_Type *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:ga1c270f17c425d5d9c844aed147e973a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the data toggle.  <a href="#ga1c270f17c425d5d9c844aed147e973a9">More...</a><br/></td></tr>
<tr class="separator:ga1c270f17c425d5d9c844aed147e973a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17b7e12a6373351f12a81b361c12fff"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gaf17b7e12a6373351f12a81b361c12fff">nrf_usbd_ep_enable_check</a> (NRF_USBD_Type const *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:gaf17b7e12a6373351f12a81b361c12fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking whether the endpoint is enabled.  <a href="#gaf17b7e12a6373351f12a81b361c12fff">More...</a><br/></td></tr>
<tr class="separator:gaf17b7e12a6373351f12a81b361c12fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d51ddddc9b82ce7a0f20d9d0c3eced"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga28d51ddddc9b82ce7a0f20d9d0c3eced">nrf_usbd_ep_enable</a> (NRF_USBD_Type *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:ga28d51ddddc9b82ce7a0f20d9d0c3eced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the selected endpoint.  <a href="#ga28d51ddddc9b82ce7a0f20d9d0c3eced">More...</a><br/></td></tr>
<tr class="separator:ga28d51ddddc9b82ce7a0f20d9d0c3eced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec0b9257ca5204d17bbc0ddbc21eb45"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga2ec0b9257ca5204d17bbc0ddbc21eb45">nrf_usbd_ep_disable</a> (NRF_USBD_Type *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:ga2ec0b9257ca5204d17bbc0ddbc21eb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling the selected endpoint.  <a href="#ga2ec0b9257ca5204d17bbc0ddbc21eb45">More...</a><br/></td></tr>
<tr class="separator:ga2ec0b9257ca5204d17bbc0ddbc21eb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5097e513286061bb0dd1a104606830e"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gad5097e513286061bb0dd1a104606830e">nrf_usbd_ep_all_disable</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:gad5097e513286061bb0dd1a104606830e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling all endpoints.  <a href="#gad5097e513286061bb0dd1a104606830e">More...</a><br/></td></tr>
<tr class="separator:gad5097e513286061bb0dd1a104606830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae22f114852bc426680af00d510127da4"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gae22f114852bc426680af00d510127da4">nrf_usbd_ep_default_config</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:gae22f114852bc426680af00d510127da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting the default endpoint configuration.  <a href="#gae22f114852bc426680af00d510127da4">More...</a><br/></td></tr>
<tr class="separator:gae22f114852bc426680af00d510127da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab783f26d050b386fffbcefc2cdf459cf"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gab783f26d050b386fffbcefc2cdf459cf">nrf_usbd_ep_stall</a> (NRF_USBD_Type *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:gab783f26d050b386fffbcefc2cdf459cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for stalling the selected endpoint.  <a href="#gab783f26d050b386fffbcefc2cdf459cf">More...</a><br/></td></tr>
<tr class="separator:gab783f26d050b386fffbcefc2cdf459cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad80e8d94a4ab714d952b28b07e310a14"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gad80e8d94a4ab714d952b28b07e310a14">nrf_usbd_ep_unstall</a> (NRF_USBD_Type *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:gad80e8d94a4ab714d952b28b07e310a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for unstalling the selected endpoint.  <a href="#gad80e8d94a4ab714d952b28b07e310a14">More...</a><br/></td></tr>
<tr class="separator:gad80e8d94a4ab714d952b28b07e310a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012c9fa1b3ef65862f6a37184f5cce33"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga012c9fa1b3ef65862f6a37184f5cce33">nrf_usbd_isosplit_set</a> (NRF_USBD_Type *p_reg, <a class="el" href="group__nrf__usbd__hal.html#ga2b397851455aff39727f26fa7f52a26c">nrf_usbd_isosplit_t</a> split)</td></tr>
<tr class="memdesc:ga012c9fa1b3ef65862f6a37184f5cce33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for configuring the isochronous buffer splitting.  <a href="#ga012c9fa1b3ef65862f6a37184f5cce33">More...</a><br/></td></tr>
<tr class="separator:ga012c9fa1b3ef65862f6a37184f5cce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fae989351d356e8e77227861f6ecdd5"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE <br class="typebreak"/>
<a class="el" href="group__nrf__usbd__hal.html#ga2b397851455aff39727f26fa7f52a26c">nrf_usbd_isosplit_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga3fae989351d356e8e77227861f6ecdd5">nrf_usbd_isosplit_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga3fae989351d356e8e77227861f6ecdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the isochronous buffer splitting configuration.  <a href="#ga3fae989351d356e8e77227861f6ecdd5">More...</a><br/></td></tr>
<tr class="separator:ga3fae989351d356e8e77227861f6ecdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ff06baed465b177e31375ce001d0d1"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gae0ff06baed465b177e31375ce001d0d1">nrf_usbd_framecntr_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:gae0ff06baed465b177e31375ce001d0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting current frame counter.  <a href="#gae0ff06baed465b177e31375ce001d0d1">More...</a><br/></td></tr>
<tr class="separator:gae0ff06baed465b177e31375ce001d0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga944a5e908b4e3a16461bf04db92bafac"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga944a5e908b4e3a16461bf04db92bafac">nrf_usbd_lowpower_enable</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:ga944a5e908b4e3a16461bf04db92bafac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for entering into the USB low power mode.  <a href="#ga944a5e908b4e3a16461bf04db92bafac">More...</a><br/></td></tr>
<tr class="separator:ga944a5e908b4e3a16461bf04db92bafac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7553635a772c5cf7496efe211b6e56b9"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga7553635a772c5cf7496efe211b6e56b9">nrf_usbd_lowpower_disable</a> (NRF_USBD_Type *p_reg)</td></tr>
<tr class="memdesc:ga7553635a772c5cf7496efe211b6e56b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for exiting from the USB low power mode.  <a href="#ga7553635a772c5cf7496efe211b6e56b9">More...</a><br/></td></tr>
<tr class="separator:ga7553635a772c5cf7496efe211b6e56b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b635f1aec033d9e66dc4776b4e1e3bd"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga8b635f1aec033d9e66dc4776b4e1e3bd">nrf_usbd_lowpower_check</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga8b635f1aec033d9e66dc4776b4e1e3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking the state of the low power mode.  <a href="#ga8b635f1aec033d9e66dc4776b4e1e3bd">More...</a><br/></td></tr>
<tr class="separator:ga8b635f1aec033d9e66dc4776b4e1e3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8960604f2e9a410468de65bd29bbdddc"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga8960604f2e9a410468de65bd29bbdddc">nrf_usbd_isoinconfig_set</a> (NRF_USBD_Type *p_reg, <a class="el" href="group__nrf__usbd__hal.html#ga2328f0becb99ca74db0490cd48af4861">nrf_usbd_isoinconfig_t</a> config)</td></tr>
<tr class="memdesc:ga8960604f2e9a410468de65bd29bbdddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for configuring ISO IN endpoint response to an IN token when no data is ready to be sent.  <a href="#ga8960604f2e9a410468de65bd29bbdddc">More...</a><br/></td></tr>
<tr class="separator:ga8960604f2e9a410468de65bd29bbdddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf665a23aabc0f564ecb8262ddd781c33"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE <br class="typebreak"/>
<a class="el" href="group__nrf__usbd__hal.html#ga2328f0becb99ca74db0490cd48af4861">nrf_usbd_isoinconfig_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gaf665a23aabc0f564ecb8262ddd781c33">nrf_usbd_isoinconfig_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:gaf665a23aabc0f564ecb8262ddd781c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the cofiguration of ISO IN endpoint response to an IN token when no data is ready to be sent.  <a href="#gaf665a23aabc0f564ecb8262ddd781c33">More...</a><br/></td></tr>
<tr class="separator:gaf665a23aabc0f564ecb8262ddd781c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a00900f9f1485b4d8aa35fedb0a7f7"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gaa5a00900f9f1485b4d8aa35fedb0a7f7">nrf_usbd_ep_easydma_set</a> (NRF_USBD_Type *p_reg, uint8_t ep, uint32_t ptr, uint32_t maxcnt)</td></tr>
<tr class="memdesc:gaa5a00900f9f1485b4d8aa35fedb0a7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for configuring the EasyDMA channel.  <a href="#gaa5a00900f9f1485b4d8aa35fedb0a7f7">More...</a><br/></td></tr>
<tr class="separator:gaa5a00900f9f1485b4d8aa35fedb0a7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8ca4b4f0d2a5ce041cd654bfe9884d"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga6d8ca4b4f0d2a5ce041cd654bfe9884d">nrf_usbd_ep_amount_get</a> (NRF_USBD_Type const *p_reg, uint8_t ep)</td></tr>
<tr class="memdesc:ga6d8ca4b4f0d2a5ce041cd654bfe9884d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting number of transferred bytes.  <a href="#ga6d8ca4b4f0d2a5ce041cd654bfe9884d">More...</a><br/></td></tr>
<tr class="separator:ga6d8ca4b4f0d2a5ce041cd654bfe9884d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Setup command frame functions.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf3e2d8469f795294508b216a5fa36cb2"></a>Functions for setting up command frame part access. </p>
</td></tr>
<tr class="memitem:gad9fa77301e304f15905f04db5ace16de"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gad9fa77301e304f15905f04db5ace16de">nrf_usbd_setup_bmrequesttype_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:gad9fa77301e304f15905f04db5ace16de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading BMREQUESTTYPE - part of the SETUP packet.  <a href="#gad9fa77301e304f15905f04db5ace16de">More...</a><br/></td></tr>
<tr class="separator:gad9fa77301e304f15905f04db5ace16de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fd0236b99b50a8003d22e84b8571f45"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga5fd0236b99b50a8003d22e84b8571f45">nrf_usbd_setup_brequest_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga5fd0236b99b50a8003d22e84b8571f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading BMREQUEST - part of the SETUP packet.  <a href="#ga5fd0236b99b50a8003d22e84b8571f45">More...</a><br/></td></tr>
<tr class="separator:ga5fd0236b99b50a8003d22e84b8571f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa425fab84d090108aa23fdab54c4fae3"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gaa425fab84d090108aa23fdab54c4fae3">nrf_usbd_setup_wvalue_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:gaa425fab84d090108aa23fdab54c4fae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading WVALUE - part of the SETUP packet.  <a href="#gaa425fab84d090108aa23fdab54c4fae3">More...</a><br/></td></tr>
<tr class="separator:gaa425fab84d090108aa23fdab54c4fae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb4fa211dba6564eb365c50bbebd8c5a"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#gafb4fa211dba6564eb365c50bbebd8c5a">nrf_usbd_setup_windex_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:gafb4fa211dba6564eb365c50bbebd8c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading WINDEX - part of the SETUP packet.  <a href="#gafb4fa211dba6564eb365c50bbebd8c5a">More...</a><br/></td></tr>
<tr class="separator:gafb4fa211dba6564eb365c50bbebd8c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad7b416191ca996a435e79b2f6c60cd"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__usbd__hal.html#ga0ad7b416191ca996a435e79b2f6c60cd">nrf_usbd_setup_wlength_get</a> (NRF_USBD_Type const *p_reg)</td></tr>
<tr class="memdesc:ga0ad7b416191ca996a435e79b2f6c60cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading WLENGTH - part of the SETUP packet.  <a href="#ga0ad7b416191ca996a435e79b2f6c60cd">More...</a><br/></td></tr>
<tr class="separator:ga0ad7b416191ca996a435e79b2f6c60cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Hardware access layer for managing the Universal Serial Bus Device (USBD) peripheral. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gab94e2e9074a572f025cbbbbfb49852ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EP_NR_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;((uint8_t)(((uint8_t)(ep)) &amp; 0xFU))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for extracting the endpoint number from the specified endpoint identifier. </p>
<p>Macro that strips out the information about endpoint direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Endpoint number. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5517794f8da667831ee7a22bd476a4e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EP_VALIDATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(                                              \</div>
<div class="line">    (<a class="code" href="group__nrf__usbd__hal.html#ga3d429071b3003910f7aa3027fc2597d6" title="Macro for checking the endpoint direction.">NRF_USBD_EPIN_CHECK</a>(ep) &amp;&amp; (<a class="code" href="group__nrf__usbd__hal.html#gab94e2e9074a572f025cbbbbfb49852ad" title="Macro for extracting the endpoint number from the specified endpoint identifier.">NRF_USBD_EP_NR_GET</a>(ep) &lt; <a class="code" href="group__nrf__usbd__hal.html#ga44b9553409d9c4785eebaaadd4586f0f" title="Total number of IN endpoints.">NRF_USBD_EPIN_CNT</a>))   \</div>
<div class="line">    ||                                                                          \</div>
<div class="line">    (<a class="code" href="group__nrf__usbd__hal.html#gaa3ed152cfe989b125a93a2687d8f7eae" title="Macro for checking endpoint direction.">NRF_USBD_EPOUT_CHECK</a>(ep) &amp;&amp; (<a class="code" href="group__nrf__usbd__hal.html#gab94e2e9074a572f025cbbbbfb49852ad" title="Macro for extracting the endpoint number from the specified endpoint identifier.">NRF_USBD_EP_NR_GET</a>(ep) &lt; <a class="code" href="group__nrf__usbd__hal.html#ga437407a2f8d28b360a4ec9eb816e729d" title="Total number of OUT endpoints.">NRF_USBD_EPOUT_CNT</a>)) \</div>
<div class="line">    )</div>
</div><!-- fragment -->
<p>Macro for checking if given number is valid endpoint number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The endpoint is valid. </td></tr>
    <tr><td class="paramname">false</td><td>The endpoint is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9be1e5cf3c38d21e1116c2771ab86bcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EPIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">epnr</td><td>)</td>
          <td>&#160;&#160;&#160;(((uint8_t)(epnr)) | <a class="el" href="group__nrf__usbd__hal.html#ga6357a6cf3e265f3f1c40077582cdc814">NRF_USBD_EP_DIR_IN</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for making the IN endpoint identifier from endpoint number. </p>
<p>Macro that sets direction bit to make IN endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epnr</td><td>Endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IN Endpoint identifier. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d429071b3003910f7aa3027fc2597d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EPIN_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;( (((uint8_t)(ep)) &amp; <a class="el" href="group__nrf__usbd__hal.html#gafab440dd7f6a642c240348da60092eb3">NRF_USBD_EP_DIR_Msk</a>) == <a class="el" href="group__nrf__usbd__hal.html#ga6357a6cf3e265f3f1c40077582cdc814">NRF_USBD_EP_DIR_IN</a>  )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for checking the endpoint direction. </p>
<p>This macro checks if the specified endpoint has the IN direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The endpoint direction is IN. </td></tr>
    <tr><td class="paramname">false</td><td>The endpoint direction is OUT. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga44b9553409d9c4785eebaaadd4586f0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EPIN_CNT&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of IN endpoints. </p>
<p>Total number of IN endpoint (including ISOCHRONOUS). </p>

</div>
</div>
<a class="anchor" id="ga47229aa88f189c973e6c93a942772a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EPISO_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="group__nrf__usbd__hal.html#gab94e2e9074a572f025cbbbbfb49852ad">NRF_USBD_EP_NR_GET</a>(ep) &gt;= <a class="el" href="group__nrf__usbd__hal.html#ga2885b53c22521a2a3e2dbcda0dd0f044">NRF_USBD_EPISO_FIRST</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for checking if endpoint is isochronous. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>It can be endpoint identifier or just endpoint number to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The endpoint is isochronous type. </td></tr>
    <tr><td class="paramname">false</td><td>The endpoint is bulk of interrupt type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2885b53c22521a2a3e2dbcda0dd0f044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EPISO_FIRST&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>First isochronous endpoint number. </p>
<p>The number of the first isochronous endpoint. </p>

</div>
</div>
<a class="anchor" id="gae8241e0e42223e58adb98e2fb7b71a3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EPISOOUT_NO_DATA&#160;&#160;&#160;((size_t)(-1))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not isochronous data frame received. </p>
<p>Special value returned by <a class="el" href="group__nrf__usbd__hal.html#ga781e617b1d8866be26f485f3b7f8320f">nrf_usbd_episoout_size_get</a> function that means that data frame was not received at all. This allows differentiate between situations when zero size data comes or no data comes at all on isochronous endpoint. </p>

</div>
</div>
<a class="anchor" id="ga8b6d96a8d69d5283919896d6f5b54b01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EPOUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">epnr</td><td>)</td>
          <td>&#160;&#160;&#160;(((uint8_t)(epnr)) | <a class="el" href="group__nrf__usbd__hal.html#ga59e374ef98d3521cb386c425d43dd36d">NRF_USBD_EP_DIR_OUT</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for making the OUT endpoint identifier from endpoint number. </p>
<p>Macro that sets direction bit to make OUT endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epnr</td><td>Endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OUT Endpoint identifier. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3ed152cfe989b125a93a2687d8f7eae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EPOUT_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;( (((uint8_t)(ep)) &amp; <a class="el" href="group__nrf__usbd__hal.html#gafab440dd7f6a642c240348da60092eb3">NRF_USBD_EP_DIR_Msk</a>) == <a class="el" href="group__nrf__usbd__hal.html#ga59e374ef98d3521cb386c425d43dd36d">NRF_USBD_EP_DIR_OUT</a> )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for checking endpoint direction. </p>
<p>This macro checks if given endpoint has OUT direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The endpoint direction is OUT </td></tr>
    <tr><td class="paramname">false</td><td>The endpoint direction is IN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga437407a2f8d28b360a4ec9eb816e729d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_EPOUT_CNT&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of OUT endpoints. </p>
<p>Total number of OUT endpoint (including ISOCHRONOUS). </p>

</div>
</div>
<a class="anchor" id="ga6bf887bf2b95efe9128ba52eccfae9a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_USBD_FRAMECNTR_SIZE&#160;&#160;&#160;( (USBD_FRAMECNTR_FRAMECNTR_Msk &gt;&gt; USBD_FRAMECNTR_FRAMECNTR_Pos) + 1UL )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frame counter size. </p>
<p>The number of counts that can be fitted into frame counter. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga86af0982c97904e6f14200709346f93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbd__hal.html#ga86af0982c97904e6f14200709346f93e">nrf_usbd_dpdmvalue_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DPDMVALUE register. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga86af0982c97904e6f14200709346f93eaa3bb7c1a49d424f6bdfe82463cb86abb"></a>NRF_USBD_DPDMVALUE_RESUME</em>&nbsp;</td><td class="fielddoc">
<p>Generate RESUME signal. Signal is generated for 50&#160;us or 5&#160;ms, depending on bus state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga86af0982c97904e6f14200709346f93ea5a47d0fdb93688f7dee41660599df12b"></a>NRF_USBD_DPDMVALUE_J</em>&nbsp;</td><td class="fielddoc">
<p>D+ Forced high, D- forced low (J state) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga86af0982c97904e6f14200709346f93ea5e1e542f5c263ee2d74b5e53887bf7d6"></a>NRF_USBD_DPMVALUE_K</em>&nbsp;</td><td class="fielddoc">
<p>D+ Forced low, D- forced high (K state) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gac7a52ea2795a7ec86d88d2479115e8ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbd__hal.html#gac7a52ea2795a7ec86d88d2479115e8ab">nrf_usbd_dtoggle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data toggle value or operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggac7a52ea2795a7ec86d88d2479115e8abad544fd91f626686855661c029f6783ed"></a>NRF_USBD_DTOGGLE_NOP</em>&nbsp;</td><td class="fielddoc">
<p>No operation - do not change the current data toggle on the selected endpoint. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac7a52ea2795a7ec86d88d2479115e8aba840a6b8fd3f75337a0cf934631722bbe"></a>NRF_USBD_DTOGGLE_DATA0</em>&nbsp;</td><td class="fielddoc">
<p>Data toggle is DATA0 on the selected endpoint. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac7a52ea2795a7ec86d88d2479115e8aba1457b3fd3ca4bbcdcda2f124bd3bc4d7"></a>NRF_USBD_DTOGGLE_DATA1</em>&nbsp;</td><td class="fielddoc">
<p>Data toggle is DATA1 on the selected endpoint. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga0187f1cfcba4bbd00158f9b04ec06fe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6af83cb0aff273a343ea398411ec6e1537"></a>NRF_USBD_EVENT_USBRESET</em>&nbsp;</td><td class="fielddoc">
<p>Signals that a USB reset condition is detected on the USB lines. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6ae841c340feff31143770e2b3384a12fb"></a>NRF_USBD_EVENT_STARTED</em>&nbsp;</td><td class="fielddoc">
<p>Confirms that the EPIN[n].PTR, EPIN[n].MAXCNT, EPIN[n].CONFIG, or EPOUT[n].PTR, EPOUT[n].MAXCNT, and EPOUT[n].CONFIG registers have been captured on all endpoints reported in the EPSTATUS register. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6ad04c0755ec5ce1eafe1a12e46c898822"></a>NRF_USBD_EVENT_ENDEPIN0</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPIN[0] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a658cd1bb7e3c3e6f9ea2c9311e0e3162"></a>NRF_USBD_EVENT_ENDEPIN1</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPIN[1] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a2145cb9e6a9f5de4a3ccc0f323b7de3d"></a>NRF_USBD_EVENT_ENDEPIN2</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPIN[2] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a28a65e73e6e125682f483734fdbeb238"></a>NRF_USBD_EVENT_ENDEPIN3</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPIN[3] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a917c50a3234d56030ef445541dda9141"></a>NRF_USBD_EVENT_ENDEPIN4</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPIN[4] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a28b6c47ec54fccae0dcbab0bc332ce28"></a>NRF_USBD_EVENT_ENDEPIN5</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPIN[5] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a1ece33d3fd52f5dd11e82f4a40ba9c42"></a>NRF_USBD_EVENT_ENDEPIN6</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPIN[6] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a24ede0a7230ba2f6705c5594963db249"></a>NRF_USBD_EVENT_ENDEPIN7</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPIN[7] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a5d8be992cabec77f4753060597a1eddc"></a>NRF_USBD_EVENT_EP0DATADONE</em>&nbsp;</td><td class="fielddoc">
<p>An acknowledged data transfer has taken place on the control endpoint. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a5f870f773392a17f08d9494d7c8f10c6"></a>NRF_USBD_EVENT_ENDISOIN0</em>&nbsp;</td><td class="fielddoc">
<p>The whole ISOIN buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6ad5936ba41dfccd2915fc0e2ec3a887bd"></a>NRF_USBD_EVENT_ENDEPOUT0</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPOUT[0] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6af21e07f0978c2fbeb063a8ae6155276d"></a>NRF_USBD_EVENT_ENDEPOUT1</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPOUT[1] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6abf3746cb4bdbd6e337d9c6c8fd38e6af"></a>NRF_USBD_EVENT_ENDEPOUT2</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPOUT[2] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6aa9f75a485be35880d29c84ab369e9c7b"></a>NRF_USBD_EVENT_ENDEPOUT3</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPOUT[3] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a612f10f64675333dffb9fe6b5823e377"></a>NRF_USBD_EVENT_ENDEPOUT4</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPOUT[4] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6acca649675f717f169d01aaad0b919f0d"></a>NRF_USBD_EVENT_ENDEPOUT5</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPOUT[5] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a10187f674c06474e4370bca5e4b6df18"></a>NRF_USBD_EVENT_ENDEPOUT6</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPOUT[6] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6adf9facfc2406fe5808076c8751d6f2b0"></a>NRF_USBD_EVENT_ENDEPOUT7</em>&nbsp;</td><td class="fielddoc">
<p>The whole EPOUT[7] buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a4bbee040b5f6b31a32febdbf90bad881"></a>NRF_USBD_EVENT_ENDISOOUT0</em>&nbsp;</td><td class="fielddoc">
<p>The whole ISOOUT buffer has been consumed. The RAM buffer can be accessed safely by software. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6ae3cb91560fe95b107f7e7e324ecc69af"></a>NRF_USBD_EVENT_SOF</em>&nbsp;</td><td class="fielddoc">
<p>Signals that a SOF (start of frame) condition has been detected on the USB lines. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6a4dd28ded5479d8b579e4641aa486af00"></a>NRF_USBD_EVENT_USBEVENT</em>&nbsp;</td><td class="fielddoc">
<p>An event or an error not covered by the specified events has occurred, check EVENTCAUSE register to find the cause. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6ac660ce8ed22d201c0af693732a218026"></a>NRF_USBD_EVENT_EP0SETUP</em>&nbsp;</td><td class="fielddoc">
<p>A valid SETUP token has been received (and acknowledged) on the control endpoint. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga0187f1cfcba4bbd00158f9b04ec06fe6aad1c28abf725d8d615738836e651c24c"></a>NRF_USBD_EVENT_DATAEP</em>&nbsp;</td><td class="fielddoc">
<p>A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8588a7f666e82f6c441046d924ff197e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbd__hal.html#ga8588a7f666e82f6c441046d924ff197e">nrf_usbd_eventcause_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EVENTCAUSE register bit masks. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga8588a7f666e82f6c441046d924ff197ea526a378a0bce39373b3521252a404dab"></a>NRF_USBD_EVENTCAUSE_ISOOUTCRC_MASK</em>&nbsp;</td><td class="fielddoc">
<p>CRC error was detected on isochronous OUT endpoint 8. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8588a7f666e82f6c441046d924ff197ea68761f3edd6f26802ec415c63315204d"></a>NRF_USBD_EVENTCAUSE_SUSPEND_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Signals that the USB lines have been seen idle long enough for the device to enter suspend. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8588a7f666e82f6c441046d924ff197ea9774c93c16b0f8d3557e1794df33d608"></a>NRF_USBD_EVENTCAUSE_RESUME_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Signals that a RESUME condition (K state or activity restart) has been detected on the USB lines. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8588a7f666e82f6c441046d924ff197eaa71e0597c1c9ca8d665399d56a23b571"></a>NRF_USBD_EVENTCAUSE_WUREQ_MASK</em>&nbsp;</td><td class="fielddoc">
<p>The USBD peripheral has exited Low Power mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8588a7f666e82f6c441046d924ff197ea124d310529b710dba2b27bbfeaa23468"></a>NRF_USBD_EVENTCAUSE_READY_MASK</em>&nbsp;</td><td class="fielddoc">
<p>MAC is ready for normal operation, rised few us after USBD enabling. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gabb0886b59ca193e84b9405ea55444e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbd__hal.html#gabb0886b59ca193e84b9405ea55444e99">nrf_usbd_int_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD interrupts. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99ac37d68fdbd9aef08827ce94b49330ad7"></a>NRF_USBD_INT_USBRESET_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for USBRESET event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99ada4192c314b47c030ca33d8c4e586305"></a>NRF_USBD_INT_STARTED_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for STARTED event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99af575309faaea4de9909ee01d1da6debb"></a>NRF_USBD_INT_ENDEPIN0_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPIN[0] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99ae5422bd3dce7ac7c604a82c56c565fba"></a>NRF_USBD_INT_ENDEPIN1_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPIN[1] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99ae6dd16ba2e80c5d6e42b28925f214e53"></a>NRF_USBD_INT_ENDEPIN2_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPIN[2] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a6fa982339a54bc3a3dd70ee379033a68"></a>NRF_USBD_INT_ENDEPIN3_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPIN[3] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a47f1b11f42f5fabd892f23ef98917b43"></a>NRF_USBD_INT_ENDEPIN4_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPIN[4] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99accdc728d1dd0ffb3aa683b2d1dcb1126"></a>NRF_USBD_INT_ENDEPIN5_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPIN[5] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a90c66c4312063be527effed166ef0189"></a>NRF_USBD_INT_ENDEPIN6_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPIN[6] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99afd0bbd63552837726376b0294c1ec614"></a>NRF_USBD_INT_ENDEPIN7_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPIN[7] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a748b2373c4e31c7b325bf21ec76cb0f4"></a>NRF_USBD_INT_EP0DATADONE_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for EP0DATADONE event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a880f7153500a33e64bdc99d47281d18e"></a>NRF_USBD_INT_ENDISOIN0_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDISOIN[0] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a5bd2330fe36dd832277019d9486c1120"></a>NRF_USBD_INT_ENDEPOUT0_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPOUT[0] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99ac38bd0cd841901151c1b6454b27a4e06"></a>NRF_USBD_INT_ENDEPOUT1_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPOUT[1] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a9e00b89329eff80a86818b090a174d09"></a>NRF_USBD_INT_ENDEPOUT2_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPOUT[2] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a76a9c94091a0e32af6d059bdfbdca865"></a>NRF_USBD_INT_ENDEPOUT3_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPOUT[3] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99aa2151d91bb090113401dfd2c83d491d3"></a>NRF_USBD_INT_ENDEPOUT4_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPOUT[4] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a767506405908faf164481e4db334484a"></a>NRF_USBD_INT_ENDEPOUT5_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPOUT[5] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a3fca2864d752b289e59be96918792298"></a>NRF_USBD_INT_ENDEPOUT6_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPOUT[6] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99ab115f6cb829a6b69c5a89c23ddef6ecf"></a>NRF_USBD_INT_ENDEPOUT7_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDEPOUT[7] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a241af2b50bf2876d78573d5eae0e2770"></a>NRF_USBD_INT_ENDISOOUT0_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for ENDISOOUT[0] event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a234d4ad6a36d8a9e04b4f1d09ac79540"></a>NRF_USBD_INT_SOF_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for SOF event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a455c86aa80aa62952865aef26ca3ec6f"></a>NRF_USBD_INT_USBEVENT_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for USBEVENT event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99a596911d01498576994e83241e979d4e5"></a>NRF_USBD_INT_EP0SETUP_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for EP0SETUP event. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabb0886b59ca193e84b9405ea55444e99ade8a86638b6c4777f261671ac4a72dca"></a>NRF_USBD_INT_DATAEP_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Enable or disable interrupt for EPDATA event. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga2328f0becb99ca74db0490cd48af4861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbd__hal.html#ga2328f0becb99ca74db0490cd48af4861">nrf_usbd_isoinconfig_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISOINCONFIG configurations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga2328f0becb99ca74db0490cd48af4861af5220a5dd7d3def691031ebfc83e27be"></a>NRF_USBD_ISOINCONFIG_NORESP</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint does not respond to an ISO IN token when no data is ready. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2328f0becb99ca74db0490cd48af4861ac85cee2b3da471763645cfbf36bbbff5"></a>NRF_USBD_ISOINCONFIG_ZERODATA</em>&nbsp;</td><td class="fielddoc">
<p>Endpoint responds with a zero-length data packet to an ISO IN token when no data is ready. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga2b397851455aff39727f26fa7f52a26c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbd__hal.html#ga2b397851455aff39727f26fa7f52a26c">nrf_usbd_isosplit_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ISOSPLIT configurations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga2b397851455aff39727f26fa7f52a26ca75c5f68dab4ec2a06a61f5bedbde1b68"></a>NRF_USBD_ISOSPLIT_ONEDIR</em>&nbsp;</td><td class="fielddoc">
<p>Full buffer dedicated to either ISO IN or OUT. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2b397851455aff39727f26fa7f52a26cafa3a5cc6980ae430de05d2fa27941b58"></a>NRF_USBD_ISOSPLIT_HALF</em>&nbsp;</td><td class="fielddoc">
<p>Buffer divided in half. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gafdd0cd13c3c89afb8a05dae04306a81f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbd__hal.html#gafdd0cd13c3c89afb8a05dae04306a81f">nrf_usbd_short_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD shorts. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggafdd0cd13c3c89afb8a05dae04306a81fa1b7356a0a28ca3d52198b78ad6fefe4c"></a>NRF_USBD_SHORT_EP0DATADONE_STARTEPIN0_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Shortcut between EP0DATADONE event and STARTEPIN0 task. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggafdd0cd13c3c89afb8a05dae04306a81fa0b3f874c1ef8311e523b801fadd4b3e9"></a>NRF_USBD_SHORT_EP0DATADONE_STARTEPOUT0_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Shortcut between EP0DATADONE event and STARTEPOUT0 task. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggafdd0cd13c3c89afb8a05dae04306a81fa81e66f5768d57e60244893d93c1d3bc8"></a>NRF_USBD_SHORT_EP0DATADONE_EP0STATUS_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Shortcut between EP0DATADONE event and EP0STATUS task. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggafdd0cd13c3c89afb8a05dae04306a81fad0617183c52a6bb7ca15c4e36b3d6e38"></a>NRF_USBD_SHORT_ENDEPOUT0_EP0STATUS_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Shortcut between ENDEPOUT[0] event and EP0STATUS task. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggafdd0cd13c3c89afb8a05dae04306a81fa1d863080219bf895b1e723b8201fb2a9"></a>NRF_USBD_SHORT_ENDEPOUT0_EP0RCVOUT_MASK</em>&nbsp;</td><td class="fielddoc">
<p>Shortcut between ENDEPOUT[0] event and EP0RCVOUT task. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gacef518da985b1dea4e65fb035cc3ffb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__usbd__hal.html#gacef518da985b1dea4e65fb035cc3ffb7">nrf_usbd_task_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD tasks. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7aaa692795b5120e01bf399355bf90c18c"></a>NRF_USBD_TASK_STARTEPIN0</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPIN[0].PTR, EPIN[0].MAXCNT, and EPIN[0].CONFIG registers values, and enables control endpoint IN 0 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a47bbcd684ff4a662d5ef07efbca96c7d"></a>NRF_USBD_TASK_STARTEPIN1</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPIN[1].PTR, EPIN[1].MAXCNT, and EPIN[1].CONFIG registers values, and enables data endpoint IN 1 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a0ab46fe3aca622bb2dbeef5237433e42"></a>NRF_USBD_TASK_STARTEPIN2</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPIN[2].PTR, EPIN[2].MAXCNT, and EPIN[2].CONFIG registers values, and enables data endpoint IN 2 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a2814d3219dd0804b7287411f30f91ead"></a>NRF_USBD_TASK_STARTEPIN3</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPIN[3].PTR, EPIN[3].MAXCNT, and EPIN[3].CONFIG registers values, and enables data endpoint IN 3 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7ae804a47cbdd93d97696bfd18c36a94ee"></a>NRF_USBD_TASK_STARTEPIN4</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPIN[4].PTR, EPIN[4].MAXCNT, and EPIN[4].CONFIG registers values, and enables data endpoint IN 4 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7af6e7f1750309ae67fe20f3032af514b9"></a>NRF_USBD_TASK_STARTEPIN5</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPIN[5].PTR, EPIN[5].MAXCNT, and EPIN[5].CONFIG registers values, and enables data endpoint IN 5 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7ad26ab7b45ef225a275e8d239cf0cedf1"></a>NRF_USBD_TASK_STARTEPIN6</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPIN[6].PTR, EPIN[6].MAXCNT, and EPIN[6].CONFIG registers values, and enables data endpoint IN 6 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7ae5181a7dab48989bbe300e67a26703cd"></a>NRF_USBD_TASK_STARTEPIN7</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPIN[7].PTR, EPIN[7].MAXCNT, and EPIN[7].CONFIG registers values, and enables data endpoint IN 7 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a0907bfacd52e75c55970b06b40c6f1d6"></a>NRF_USBD_TASK_STARTISOIN</em>&nbsp;</td><td class="fielddoc">
<p>Captures the ISOIN.PTR, ISOIN.MAXCNT, and ISOIN.CONFIG registers values, and enables sending data on ISO endpoint 8. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a3a2aa3531997cacc5c710f0b6a3a8bca"></a>NRF_USBD_TASK_STARTEPOUT0</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPOUT[0].PTR, EPOUT[0].MAXCNT, and EPOUT[0].CONFIG registers values, and enables control endpoint 0 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7aeff7635ea0a9fc83aa4533927c2cb12d"></a>NRF_USBD_TASK_STARTEPOUT1</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPOUT[1].PTR, EPOUT[1].MAXCNT, and EPOUT[1].CONFIG registers values, and enables data endpoint 1 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a6ac488aaacf506e91c384e41406254bb"></a>NRF_USBD_TASK_STARTEPOUT2</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPOUT[2].PTR, EPOUT[2].MAXCNT, and EPOUT[2].CONFIG registers values, and enables data endpoint 2 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7ac1afd870aca0d6f544cd7f8c8dec77b8"></a>NRF_USBD_TASK_STARTEPOUT3</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPOUT[3].PTR, EPOUT[3].MAXCNT, and EPOUT[3].CONFIG registers values, and enables data endpoint 3 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a6c070678faad2173be91ecf9c130d803"></a>NRF_USBD_TASK_STARTEPOUT4</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPOUT[4].PTR, EPOUT[4].MAXCNT, and EPOUT[4].CONFIG registers values, and enables data endpoint 4 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a6082df80a2229390a497b6a7ad8eaf50"></a>NRF_USBD_TASK_STARTEPOUT5</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPOUT[5].PTR, EPOUT[5].MAXCNT, and EPOUT[5].CONFIG registers values, and enables data endpoint 5 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7adcda72f0323184b6daa5be2cdf2c8300"></a>NRF_USBD_TASK_STARTEPOUT6</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPOUT[6].PTR, EPOUT[6].MAXCNT, and EPOUT[6].CONFIG registers values, and enables data endpoint 6 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7aea65678c751ab58f6fed90df07ebf70e"></a>NRF_USBD_TASK_STARTEPOUT7</em>&nbsp;</td><td class="fielddoc">
<p>Captures the EPOUT[7].PTR, EPOUT[7].MAXCNT, and EPOUT[7].CONFIG registers values, and enables data endpoint 7 to respond to traffic from host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7ab1d149e5b95fbb7297a22e196222cb36"></a>NRF_USBD_TASK_STARTISOOUT</em>&nbsp;</td><td class="fielddoc">
<p>Captures the ISOOUT.PTR, ISOOUT.MAXCNT, and ISOOUT.CONFIG registers values, and enables receiving of data on ISO endpoint 8. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a4972fc44d7c126e2d70108582c6808d5"></a>NRF_USBD_TASK_EP0RCVOUT</em>&nbsp;</td><td class="fielddoc">
<p>Allows OUT data stage on the control endpoint 0. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a52811cb45db47f85042ab844929e8638"></a>NRF_USBD_TASK_EP0STATUS</em>&nbsp;</td><td class="fielddoc">
<p>Allows status stage on the control endpoint 0. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7ad4a98ee0874ff4f64285dbbebf258bd9"></a>NRF_USBD_TASK_EP0STALL</em>&nbsp;</td><td class="fielddoc">
<p>STALLs data and status stage on the control endpoint 0. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7ac9ba27e40be0a06543e210ae50915cca"></a>NRF_USBD_TASK_DRIVEDPDM</em>&nbsp;</td><td class="fielddoc">
<p>Forces D+ and D-lines to the state defined in the DPDMVALUE register. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacef518da985b1dea4e65fb035cc3ffb7a3344ae7c97a03e4c3a24c456f13f50e2"></a>NRF_USBD_TASK_NODRIVEDPDM</em>&nbsp;</td><td class="fielddoc">
<p>Stops forcing D+ and D- lines to any state (USB engine takes control). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga560e5d2709b79666577a22053b29d257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_disable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for disabling the USBD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3f0f369fe4c04df616590d69487339c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_dpdmvalue_set </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#ga86af0982c97904e6f14200709346f93e">nrf_usbd_dpdmvalue_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for configuring the value to be forced on the bus on the DRIVEDPDM task. </p>
<p>The selected state will be forced on the bus when <a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7ac9ba27e40be0a06543e210ae50915cca">NRF_USBD_TASK_DRIVEDPDM</a> is set. The state will be removed from the bus on <a class="el" href="group__nrf__usbd__hal.html#ggacef518da985b1dea4e65fb035cc3ffb7a3344ae7c97a03e4c3a24c456f13f50e2">NRF_USBD_TASK_NODRIVEDPDM</a> and the control will be returned to the USBD peripheral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>State to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1c270f17c425d5d9c844aed147e973a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE <a class="el" href="group__nrf__usbd__hal.html#gac7a52ea2795a7ec86d88d2479115e8ab">nrf_usbd_dtoggle_t</a> nrf_usbd_dtoggle_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the data toggle. </p>
<p>Get the current state of data toggling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number to return the information about current data toggling.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_USBD_DTOGGLE_DATA0</td><td>Data toggle is DATA0 on selected endpoint. </td></tr>
    <tr><td class="paramname">NRF_USBD_DTOGGLE_DATA1</td><td>Data toggle is DATA1 on selected endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga60b7f36031cd0ae233d609ab390eae84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_dtoggle_set </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#gac7a52ea2795a7ec86d88d2479115e8ab">nrf_usbd_dtoggle_t</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting the data toggle. </p>
<p>Configuration of the current state of data toggling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number with the information about its direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Operation to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga562e57247a2d9890b9468d0bd73e10ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_enable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the USBD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad5097e513286061bb0dd1a104606830e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_ep_all_disable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for disabling all endpoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6d8ca4b4f0d2a5ce041cd654bfe9884d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_ep_amount_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting number of transferred bytes. </p>
<p>This function gets the number of transferred bytes in the last transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The content of the AMOUNT register. </dd></dl>

</div>
</div>
<a class="anchor" id="gae22f114852bc426680af00d510127da4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_usbd_ep_default_config </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting the default endpoint configuration. </p>
<dl class="section note"><dt>Note</dt><dd>The default configuration means that all endpoints, except for EP0 IN and EP0 OUT, are disabled. Such configuration is used after the USB device reset.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2ec0b9257ca5204d17bbc0ddbc21eb45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_ep_disable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for disabling the selected endpoint. </p>
<p>The disabled endpoint does not respond for the tokens on the USB bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint ID to be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa5a00900f9f1485b4d8aa35fedb0a7f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_ep_easydma_set </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for configuring the EasyDMA channel. </p>
<p>Configures EasyDMA for the transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier (with direction). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxcnt</td><td>Number of bytes to transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga28d51ddddc9b82ce7a0f20d9d0c3eced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_ep_enable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the selected endpoint. </p>
<p>The enabled endpoint responds for the tokens on the USB bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint ID to be enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf17b7e12a6373351f12a81b361c12fff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE bool nrf_usbd_ep_enable_check </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking whether the endpoint is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint ID to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Endpoint is enabled. </td></tr>
    <tr><td class="paramname">false</td><td>Endpoint is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae6a606967bf03d76c70bf22552a94617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE bool nrf_usbd_ep_is_stall </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking whether the selected endpoint is stalled. </p>
<p>Function to be used as a syntax sweeter for <a class="el" href="group__nrf__usbd__hal.html#ga4b4a86b907d9d16354916efa13c913f4">nrf_usbd_halted_get</a>.</p>
<p>Also as the isochronous endpoint cannot be halted - it returns always false if isochronous endpoint is checked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number with IN or OUT flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The endpoint is halted. </td></tr>
    <tr><td class="paramname">false</td><td>The endpoint is not halted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab783f26d050b386fffbcefc2cdf459cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_ep_stall </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for stalling the selected endpoint. </p>
<dl class="section note"><dt>Note</dt><dd>This function cannot be called on isochronous endpoint.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad80e8d94a4ab714d952b28b07e310a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_ep_unstall </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for unstalling the selected endpoint. </p>
<dl class="section note"><dt>Note</dt><dd>This function cannot be called on isochronous endpoint.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga165b2891148dc620c4105f1b430832ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_epdatastatus_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for clearing DATAEPSTATUS register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags defined in <a class="el" href="group__nrf__usbd__hal.html#gaf16119bd371d2d9bae89ffe785b8a08b">nrf_usbd_dataepstatus_mask_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga23746eeddcdc074aa2639fe406212a3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_epdatastatus_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting DATAEPSTATUS register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag values defined in <a class="el" href="group__nrf__usbd__hal.html#gaf16119bd371d2d9bae89ffe785b8a08b">nrf_usbd_dataepstatus_mask_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gadfa04941d3bcefa5119bc69ec39cb259"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_epdatastatus_get_and_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting and clearing DATAEPSTATUS register value. </p>
<p>Function clears all flags in register set before returning its value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag values defined in <a class="el" href="group__nrf__usbd__hal.html#gaf16119bd371d2d9bae89ffe785b8a08b">nrf_usbd_dataepstatus_mask_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga781e617b1d8866be26f485f3b7f8320f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE size_t nrf_usbd_episoout_size_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting number of the received bytes on isochronous endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier, must be an isochronous OUT endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes received or <a class="el" href="group__nrf__usbd__hal.html#gae8241e0e42223e58adb98e2fb7b71a3f">NRF_USBD_EPISOOUT_NO_DATA</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf64d7d3c97e6dd3f6cfd0ba8b5297ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_epout_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for clearing OUT endpoint to accept any new incoming traffic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier. Only OUT interrupt/bulk endpoints are accepted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga484d691a3f3ac383b700cafe2b2d2ad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE size_t nrf_usbd_epout_size_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the number of received bytes on the selected endpoint. </p>
<dl class="section note"><dt>Note</dt><dd>This function can be used on bulk, interrupt, and isochronous endpoints. </dd>
<dd>
For the function that returns different value for the ISOOUT zero transfer or no transfer at all, see the <a class="el" href="group__nrf__usbd__hal.html#ga781e617b1d8866be26f485f3b7f8320f">nrf_usbd_episoout_size_get</a> function. This function will return 0 for both cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8aad5300a3ad73ce92b98a123282c714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_epstatus_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for clearing EPSTATUS register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags defined in <a class="el" href="group__nrf__usbd__hal.html#gadbdc3f9d30d220c792ee698ea3ab290e">nrf_usbd_epstatus_mask_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6bf521fe906e06186dc3b1633cd334d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_epstatus_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting EPSTATUS register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag values defined in <a class="el" href="group__nrf__usbd__hal.html#gadbdc3f9d30d220c792ee698ea3ab290e">nrf_usbd_epstatus_mask_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac1a2a0466ceee8179df9d7d3a7e865ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_epstatus_get_and_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting and clearing EPSTATUS register value. </p>
<p>Function clears all flags in register set before returning its value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag values defined in <a class="el" href="group__nrf__usbd__hal.html#gadbdc3f9d30d220c792ee698ea3ab290e">nrf_usbd_epstatus_mask_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8d89568dfc90f11a13cc4ec011614a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_event_address_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of the specified USBD event register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address. </dd></dl>

</div>
</div>
<a class="anchor" id="ga819a09be036542e509f2fcceccf18c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE bool nrf_usbd_event_check </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving the state of the USBD event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The event has been generated. </td></tr>
    <tr><td class="paramname">false</td><td>The event has not been generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad3766f49d2d34f7e5bd7a39e2c4cc030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_event_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for clearing the specified event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6ba54cb078b7ac770ab19407d2dd5b5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE bool nrf_usbd_event_get_and_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#ga0187f1cfcba4bbd00158f9b04ec06fe6">nrf_usbd_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting and clearing the state of the specified event. </p>
<p>This function checks the state of the event and clears it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The event was set. </td></tr>
    <tr><td class="paramname">false</td><td>The event was not set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09314d6cf8bf067c28c4be5f6f900ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_eventcause_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for clearing the EVENTCAUSE flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags defined in <a class="el" href="group__nrf__usbd__hal.html#ga8588a7f666e82f6c441046d924ff197e">nrf_usbd_eventcause_mask_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6d9e732f036188c7bcffd40e1af8ddfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_eventcause_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the EVENTCAUSE register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag values defined in <a class="el" href="group__nrf__usbd__hal.html#ga8588a7f666e82f6c441046d924ff197e">nrf_usbd_eventcause_mask_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gafdbf646da698addceb7fccbf6f19562d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_eventcause_get_and_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the EVENTCAUSE register and clearing flags that are set. </p>
<p>The safest way to return current EVENTCAUSE register. All the flags that are returned would be cleared inside EVENTCAUSE register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag values defined in <a class="el" href="group__nrf__usbd__hal.html#ga8588a7f666e82f6c441046d924ff197e">nrf_usbd_eventcause_mask_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae0ff06baed465b177e31375ce001d0d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_framecntr_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting current frame counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current frame counter. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b4a86b907d9d16354916efa13c913f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_halted_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the HALTEDEPIN register value. </p>
<dl class="section note"><dt>Note</dt><dd>Use this function for the response for GetStatus() request to endpoint. To check whether the endpoint is stalled in the code, use <a class="el" href="group__nrf__usbd__hal.html#gae6a606967bf03d76c70bf22552a94617">nrf_usbd_ep_is_stall</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number with IN or OUT flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the HALTEDEPIN or HALTEDOUT register for the selected endpoint. </dd></dl>

</div>
</div>
<a class="anchor" id="ga71ac25b07069e1509d8005c56902f1fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_int_disable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for disabling the selected interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of interrupts to be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8394a8e2a2238621dd641533827e904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_int_enable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the selected interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of interrupts to be enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc0de9e2275bb65dd566400f45ac73f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_int_enable_check </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if the specified interrupts are enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of interrupts to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of enabled interrupts. </dd></dl>

</div>
</div>
<a class="anchor" id="ga66829e1a9cd3920b2ff5b17fb3d39569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_int_enable_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving the information about the enabled interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The flags of the enabled interrupts. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf665a23aabc0f564ecb8262ddd781c33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE <a class="el" href="group__nrf__usbd__hal.html#ga2328f0becb99ca74db0490cd48af4861">nrf_usbd_isoinconfig_t</a> nrf_usbd_isoinconfig_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the cofiguration of ISO IN endpoint response to an IN token when no data is ready to be sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current configuration. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8960604f2e9a410468de65bd29bbdddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_isoinconfig_set </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#ga2328f0becb99ca74db0490cd48af4861">nrf_usbd_isoinconfig_t</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for configuring ISO IN endpoint response to an IN token when no data is ready to be sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Required configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3fae989351d356e8e77227861f6ecdd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE <a class="el" href="group__nrf__usbd__hal.html#ga2b397851455aff39727f26fa7f52a26c">nrf_usbd_isosplit_t</a> nrf_usbd_isosplit_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the isochronous buffer splitting configuration. </p>
<p>This function gets the current isochronous buffer splitting configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current configuration. </dd></dl>

</div>
</div>
<a class="anchor" id="ga012c9fa1b3ef65862f6a37184f5cce33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_isosplit_set </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#ga2b397851455aff39727f26fa7f52a26c">nrf_usbd_isosplit_t</a>&#160;</td>
          <td class="paramname"><em>split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for configuring the isochronous buffer splitting. </p>
<p>This function configures isochronous buffer splitting between IN and OUT endpoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">split</td><td>Required configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b635f1aec033d9e66dc4776b4e1e3bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE bool nrf_usbd_lowpower_check </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking the state of the low power mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The USBD is in low power mode. </td></tr>
    <tr><td class="paramname">false</td><td>The USBD is not in low power mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7553635a772c5cf7496efe211b6e56b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_lowpower_disable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for exiting from the USB low power mode. </p>
<p>After this function is called, the clock source for the USBD is connected internally. The <a class="el" href="group__nrf__usbd__hal.html#gga8588a7f666e82f6c441046d924ff197eaa71e0597c1c9ca8d665399d56a23b571">NRF_USBD_EVENTCAUSE_WUREQ_MASK</a> event will be generated and then the USBD registers can be accessed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__nrf__usbd__hal.html#ga944a5e908b4e3a16461bf04db92bafac" title="Function for entering into the USB low power mode.">nrf_usbd_lowpower_enable</a> </dd>
<dd>
<a class="el" href="group__nrf__usbd__hal.html#ga8b635f1aec033d9e66dc4776b4e1e3bd" title="Function for checking the state of the low power mode.">nrf_usbd_lowpower_check</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga944a5e908b4e3a16461bf04db92bafac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_lowpower_enable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for entering into the USB low power mode. </p>
<p>After this function is called, the clock source from the USBD is disconnected internally. After this function is called, most of the USBD registers cannot be accessed anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__nrf__usbd__hal.html#ga7553635a772c5cf7496efe211b6e56b9" title="Function for exiting from the USB low power mode.">nrf_usbd_lowpower_disable</a> </dd>
<dd>
<a class="el" href="group__nrf__usbd__hal.html#ga8b635f1aec033d9e66dc4776b4e1e3bd" title="Function for checking the state of the low power mode.">nrf_usbd_lowpower_check</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c4627bb70c2fdaf5f5e65edca4e2739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE bool nrf_usbd_pullup_check </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the current the USB pullup state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The USB pullup is enabled. </td></tr>
    <tr><td class="paramname">false</td><td>The USB pullup is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabf52b8f824fcdcb9ff10aaaecdfcabe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_pullup_disable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for disabling the USB pullup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacde4d643e37439183c87b23d9a3a077a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_pullup_enable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the USB pullup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad9fa77301e304f15905f04db5ace16de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint8_t nrf_usbd_setup_bmrequesttype_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading BMREQUESTTYPE - part of the SETUP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of BREQUESTTYPE on the last received SETUP frame. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fd0236b99b50a8003d22e84b8571f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint8_t nrf_usbd_setup_brequest_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading BMREQUEST - part of the SETUP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of BREQUEST on the last received SETUP frame. </dd></dl>

</div>
</div>
<a class="anchor" id="gafb4fa211dba6564eb365c50bbebd8c5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint16_t nrf_usbd_setup_windex_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading WINDEX - part of the SETUP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of WINDEX on the last received SETUP frame. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ad7b416191ca996a435e79b2f6c60cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint16_t nrf_usbd_setup_wlength_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading WLENGTH - part of the SETUP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of WLENGTH on the last received SETUP frame. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa425fab84d090108aa23fdab54c4fae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint16_t nrf_usbd_setup_wvalue_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading WVALUE - part of the SETUP packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of WVALUE on the last received SETUP frame. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fc4c421f2458cdaca584f38f19fc373"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_shorts_disable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for clearing shortcuts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Shortcut mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga848a66d0f7750d3c112c6e273b63eab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_shorts_enable </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting shortcuts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Shortcut mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4fdfbd1cac43daab01d95d68403799c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_shorts_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the shortcut mask. </p>
<p>Function returns shortcut register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flags of the currently enabled shortcuts. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d91d10e21fdcd9e9256eb2ac99db807"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_usbd_task_address_get </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#gacef518da985b1dea4e65fb035cc3ffb7">nrf_usbd_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of the specified USBD task register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>Task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task address. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b6305bb613dbbe0fa8fe0c946113053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_usbd_task_trigger </td>
          <td>(</td>
          <td class="paramtype">NRF_USBD_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__usbd__hal.html#gacef518da985b1dea4e65fb035cc3ffb7">nrf_usbd_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for activating the specified USBD task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>Task to be activated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="https://github.com/NordicSemiconductor/nrfx/issues" target="_blank">nrfx feedback</a> | <a href="https://devzone.nordicsemi.com/" target="_blank">Nordic DevZone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Wed Nov 6 2019" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
</script>
</div>
</body>
</html>
